###############День 1###############################################
#####Синтаксис#####

####присваивание значения объекту (если объекта раньше не было он создается)
age.robert <- 23

#В названии объекта нельзя употреблять символы +,-, %,#,) ^ и т.д. так как они зарезервированы для другого

A<-2+3 # складываем и создаем А
A<-A^2 #изменяем A с помощью самого A
A <- 3.14


#вместо <- можно употребить =, но не рекомендуется так как используется и для параметра функции
A=A*10

#Для вывода на экран значения объекта нужно просто написать его имя
A
A^0.5 #объект никак не создается и не изменяется так как нет знака присваивания
2+2*(8^6 - 2)/10 #это значение нигде не запоминается так как никуда оно не присвоилось

####функция
#+ - это оператор, сокращенный вариант функции sum()
2+2
sum(2,2)

A<-log(x=100, base=10) 
A

#название параметров функции можно не писать, сохранив их порядок
log(1024,2)

#или писать параметры в произвольном порядке, но тогда писать их названия
log(base=2, 1024) #так как у функции только два параметра, то писать можно название только одного, а второй R поймет автоматически

#синтаксис некоторых  функции упрощен, например функция справка ?
?log  #справка функции, в функции чаще всего наиболее важные параметры идут вначале - часто у них нет значения по умолчанию

#если не указываешь значение параметра по умолчанию
log(5) #по умолнчанию основание логарифма экспонента (натуральный логарифм)

?seq #задает последовательность чисел
seq(from=1, to=50, by=10)
seq() #так как все параметры по умолчанию есть
seq(to=50, 1, 10) #здесь мы прописали название только одного параметра, остальные R интерпретировал как они указаны по порядку

# если не указываешь значение параметра, у которого нет значения по умолчанию, то ошибка
log()

#упрощенные функции
seq(from=1, to=50, by=1) #то же самое можно записать проще
1:50 #: - это оператор

#ВАЖНО: В качестве значения параметра функции может выступать другая функция или объект
A<-log(2048,4/2)
length(A) #длинна последовательности
B<-seq(from=log(exp(3)), to=A, by=log(A,10))
length(B)
sum(B) #сумма элементов последовательности

A<-seq(from=log(exp(3)), to=B, by=log(B,10)) #неправильный формат значения параметра

#функция ВСЕГДА стоит справа от знака присваивания
seq(from=1, to=1000, by=5)  <- 56
seq(from=1, to=1000, by=5)  <- B

#СЛедующую строку запускать только ОБВЕДЯ ЕЁ
seq(from=log(exp(3)), to=A, by=log(A,10) # здесь забыта скобка, поэтому на консоле +, 
#то есть ожидание продолжения. Два варианта выхода - либо дописать необходимую скобку (в КОНСОЛЕ),
#либо нажать esc (тоже находясь в консоле)

########минизадание_1#########
#записать в объект Ab_3 последовательность всех четных чисел внутри числового промежутка от 1 до 10000 
#вычислить и вывести на экран логарифм по основанию 2 каждого элемента объекта Ab_3


##########Вектор - самый базовый (низший) класс объектов R###########
######Классы векторов
a <- 1 #число 1 это тоже вектор
length(a)

####Numeric and integer
A<-c(1,3,4,6, log(10,10)) #c() - это generic function создает вектора различных классов (см ниже). в данном случае мы создали вектов класса numeric
A
class(A) #возвращает класс объекта

A<-as.integer(A) #принудительно делает integer
class(A)

A<-as.numeric(A) #принудительно делает numeric

length(A) #длина вектора
class(length(A)) #длина вектора очевидно всегда целое число

B<-numeric(length=10) #создает numeric длинной 10, заполненный нулями
B
B<-numeric() #создает пустой numeric

#####Character - строковые переменные, не забываем кавычки
D <- class(A)
class(D)
A<-c("mama","papa","I want to eat 2 times", 2, class(A)) #c() - это generic function
A #обратите внимания 2 в ковычках, хотя в "I want to eat 2 times" несколько слов - это 1 элемент вектора, 
#в одном элементе вектора сharacter может быть "сколь угодно" слов, , букв, предложений 

class(A)

A<-c(mama,papa,"I want to eat 2 times", 2, class(A)) ##НЕ ЗАБЫВАЙТЕ КАВЫЧКИ

as.numeric(A) #не знает как превратить "маму" в число, NA - специальный символ, обозначающий “нет значения” (от NOT AVAILABLE)

A<-as.character(c(1,3,4,6, log(10,10))) #принудительно делает character
A #появились кавычки

as.numeric(A) #а вот превратить "1" в число смог

#в одном элементе вектора сharacter может быть "сколь угодно" слов, , букв, предложений,строк 
#запятые в ковычках не видятся функцией как переход к новому параметру 
Puchkin<-c("Пушкин", "Мороз и солнце; день чудесный!
             Еще ты дремлешь, друг прелестный -
             Пора, красавица, проснись:
             Открой сомкнуты негой взоры
           Навстречу северной Авроры,
           Звездою севера явись!")

#######Factor - вектор для обозначения категорий, обратите внимание, функцию можно написать в сколько угодно строк
C<-factor(x=c("first", "third", "forth", "second", "second","first"), 
                  levels=c("first", "second", "third", "forth", "fifth"), ordered =  TRUE) #параметр ordered позволяет указать что "first"> "second">"third"> "forth" 
C
class(C)
levels(C)
as.numeric(C) #значение становится соответсвующим порядковым номером уровня
as.numeric(levels(C)) # так как levels(C) - это character, а не factor

#######Logical
D<-c(TRUE, FALSE,FALSE, TRUE) #БЕЗ КАВЫЧЕК TRUE и FALSE это особые слова
D-1 #в алгебраических операциях TRUE=1, FALSE=0
#выясняем сколько TRUE в векторе
sum(D) #sum() - сумма всех элементов вектора

D<-as.logical(c(1,0,0, 0,1)) # и наоборот в логических операциях 1 это TRUE, 0 - FALSE
D

D<-as.logical(c(2,0,0, 4,-1)) # всё что не ноль - TRUE
D

########минизадание_2#######
#создать числовой вектор Big.data в котором будет последовательность чисел от 500 до 10000
#создать вектор character с именем ABCDEF в котором будут 6 элементов - первые 6 заглавных букв английского алфавита
#создать вектор factor с именем ABC в котором будет 6 элементов, каждый из которых одна из 3 первых букв английского алфавита 
#(в произвольной последовательности), при этом установить order, где первая буква алфавита БОЛЬШЕ второй, а вторая больше третьей

#########День 2#################
#####Операции с векторами
#Принцип: проводим операцию: каждый элемент первого вектора с таким же по порядку элементом второго вектора
#в идеальном случае длинны векторов должны быть одинаковыми
A<-1:20
B<-seq(21,80,3)
length(A)
length(B)
B-A #+,-,*,/ как будто в Excel складываешь и вычитаешь колонки
B*A
B/A
C<-c(1,3)
A-C #если векторы не равны, то меньший вектор порторяется необходимое количество раз
A-rep(x=C,times=length(A)/length(C)) #rep() - повторяет x в течении times раз
A-1
3*A # число 3 это тоже вектор длинной 1

mean(A) #среднее элементов векторов
sd(A) #среднеквадратичное отклонение
median(A) 
max(A)
min(A)
summary(A)
class(summary(A))
class(min(A))

#######использование функции с()########

##функция с() ОБЪЕДИНЯЕТ несколько векторов в один. Помните: Одно число - это тоже вектор

a<-c(4,1:50, seq(1,90,7), 40) #здесь объединяются 4 вектора
b<-c(a,seq(1,90)/4) #здесь объединяются 2 вектора


##На выходе 1) функции seq() (и многих других функций), 2) арифметических и логических операций с векторами
#получается вектор. Помните НИЧЕГО ниже вектора в R нет. Поэтому простое добавление с() бессмысленно и 
#загромождает код
a<-c(seq(3,50,4)) #НЕПРАВИЛЬНО
a<-seq(30,50,4) #Правильно




#####минизадание_3######
#1 создать вектор M как результат разности между последовательностью четных чисел и нечетных чисел от 4 до 51
#2 найти сумму элементов вектора M


######Логические операторы####
A <- seq(3,60,by=3)
A < 20 #каждый элемент вектора A сравнивается с 20 (меньший вектор повторяется необходимое число раз), 
#и если больше, то записывает вместо этого элемента FALSE, если меньше TRUE. 
#То есть на выходе логический вектор длинна которого равна А, 

B <- A < 20 #фактически логический оператор - это упрощенная функция
A < max(1:6) #не путайте < (меньше) и <- (знак присваивания)

B<- seq(0,80, length.out = 20) #length.out определяет кол-во элементов равномерно распределенных между 0 и 80
A
B
A < B #сравнивает каждый элемент вектора A с соответсвующим по счету элементом вектора B  
A < seq(9,14,by=2) #повторяет меньший вектор необходимое число раз

A <= 20 # меньше равно
A >= 20 # больше равно
A == 21 #так как = занято, то логическим оператором равно является == (два равно подряд), найди TRUE
length(A) == length(B)
B = 20 #это просто присвоит вектору значение (аналог <-), лучше не пользоваться, а то тяжело читать код

D <- A == 15
D

A != 21 #!= это неравно, а теперь найди FALSE

!TRUE # ! меняет TRUE на FALSE и наоборот
!c(TRUE,FALSE,TRUE)

!A < 15 #
A >= 15 #аналог 

!(A<15) #можно в скобках, но они избыточны, старайтесь избегать где можно

C<-factor(x=c("first", "third", "forth", "second", "second","first"), 
          levels=c("first", "second", "third", "forth"), ordered =  TRUE)

C<2 #для factor сравнивание с числом не работает
!C=="second" #это работает и для вектора character
C<"third" #так как у нас ordered factor мы можем сделать такое сравнение


A==c(9,21) #== с двумя (и более) числами не проходит, берет только первое число для сравнения (9)
sum(A==c(9,21)) #sum очень удобно для выяснения кол-ва TRUE

A %in% c(9,21) # для одновременного сравнения с несколькими числами (элементами)
sum(A %in% c(9,21,60))
!A %in% c(9,21) #все элементы A не равные 9 и 21
!(A %in% c(9,21)) #если очень некомфортно, то можно скобки в сложных выражениях
sum(!A %in% c(9,21))

K<-c("second", "forth")#character вектор
C %in% K #факторный вектор сравнивается с сharacter вектором. Это нормально


A<20 & A!=9 # & - оператор "и", чтобы результат был TRUE должно быть TRUE и слева и справа от &, иначе FALSE

A<20|A>50  # | - оператор "или", чтобы результат был TRUE должно быть TRUE или слева или справа от |

A %in% c(60,15,21)
A ==60 | A==15 | A==21 # можно написать и так, но это сложнее - больше букв

(A<40|A==51)&(A>10|A==3)&!A %in% seq(0,60,by=6) #сначало выполняется то что в скобках


g<-c(a<50,a>80) #здесь объединяются два логических вектора a<50 и  b>80, не путать с a<50&b>80

b<-c(a<40 & !a %in% seq(1,40,3)) #НЕПРАВИЛЬНО стилистически, добавление с() бесмысленно
b<-a<40 & !a %in% seq(1,40,3)    #тот же ответ но меньше скобок

######минизадание 4#####
#1.создать логический вектор Re, элемент которого равен TRUE если элемент последовательности чисел от 1 до 50 
#больше равно 30 и FALSE в противном случае

#2. создать логический вектор Rr_y, элемент которого равен TRUE, 
#если элемент последовательности чисел от 1 до 50 больше 15 и меньше 25


######Про скобки#######
#Не надо ставить скобки ВЕЗДЕ, это загромождает код и мешает его прочтению. Скобок и так будет навалом

####Скобка в начале и в конце ЦЕЛОГО выражения БЕССМЫСЛЕННА 
Re<-(seq(from=1, to=20, by=30)>30) #НЕПРАВИЛЬНО Скобка ничего не добавляет, только мешает
Re<-seq(from=1, to=20, by=30) > 30 #ПРАВИЛЬНО


####Скобки НИКОГДА НЕ ставятся если
#1. производится только одна логическая операция (>,<,==, %in% )
A<-seq(5,100,2) %in% seq(10,100,3)
A<-!seq(5,100,2) %in% seq(10,100,3) #если только одна логическая операция после ! знака не нужно скобок
#(хотя если уж очень длинная операция, то можно) ставить скобку тоже

#2. производится две логические операции (>,<,==, %in%) соединенные & или | и нет !
C<-seq(4,100,2)
B<- C>50 | C %in% c(4,40,46)

#3. производится сколько угодно логических операций, соединенных ТОЛЬКО & ИЛИ ТОЛЬКО | и не включающие !
D<-C>50 & C<=70 & C %in% seq(6,80,3) #так как & ("и") предполагает одновременное выполнение всех условий и порядок не важен 
D1<-C>50 | C==70 | C %in% seq(6,80,3) #так как | ("или") предолагает выполнение хотя бы одного условия

####Скобки МОГУТ БЫТЬ необходимы тогда, когда важен порядок выполнения логических операций

#1.производится две и более логические операции (>,<,==, %in%) соединенные & или | НО есть !
K<-!C %in% seq(6,80,3) & C<=70 #в этом случае ! относится к C %in% seq(6,80,3)
K1<-!(C %in% seq(6,80,3) & C<=70) #скобки определяют к чему относится ! ("не")

#2. Производится более двух логических операций и в них присутсвует КАК & так и |
M<-C>50 & C<=70 | C %in% seq(6,80,3) #выполняются по порядку сначала 1) C>50 & C<=70, а потом 1) | C %in% seq(6,80,3)
M1<- C>50 & (C<=70 | C %in% seq(6,80,3)) # выполняется сначала 1) C<=70 | C %in% seq(6,80,3), а потом 1) & C>50



######## Subsetting vector - вычленение из вектора его части. Два варианта#####################

#####Первый вариант - указание ВЕКТОРА ПОРЯДКОВЫХ ЧИСЕЛ элемента вектора, которые нужно выбрать

A<-letters #letters - это зарезервированное название вектора (презагруженные данные) - все буквы ангийского алфавита
A
A[20] #возвращает 20 элемент вектора
A[20:26] #возвращает c 20 по 26 элемент вектора
A[seq(1,26, by=2)] #каждый второй элемент
A[c(2,4,5)] #обязательно в этом случае нужно с(), так как в квадратных скобках должен быть вектор
A[2,4,5] # так не работает

d <- c(3,6, 10:15)
A[d] #не забывайте в квадратных скобках тоже вектор


A[c(2,4,5)] [2] #выполняется последовательно - сначала вычленяет вектор из трех элементов а потом берет второй элемент нового вектора
class(A[c(2,4,5)]) #A[c(2,4,5)] - это ветор того же класса что и A, с ним можно производить дальнейшие операции
B<-A[c(2,4,5)]

A[length(A)] #последний элемент вектора A

B<-A[length(A):1] # задом наперед
C<-letters[seq(2,length(letters),by=2)] #каждая вторая буква алфавита


####Перезаписывание и добавление элементов вектора
A[20]<-"no"
A[c(2,4,5)]<-c("second","forth","fifth") #обратите внимание длинна векторов справа и слева должна быть одинаковой
A[c(2,4,5)]<-NA #либо то что слева, должно быть меньше чем то что справа, тогда то что справа повторится необходимое число раз

length(A)
A[27]<-"no letter" # если 27 элемента раньше не было то он создается
A[27:28]<- c("no letter 1", "no letter 2")
A <-  c(A[1:26],"no letter 1", "no letter 2") #делает тоже самое но более громоздко
A[50] <-"are you stupid, English alphabet isn't so long"
A #между 28 и 50 создались NA
A[length(A)+1]<-"you are ... " #добавление нового элемента, если не знаешь длинну вектора 

A[-c(2,3)] #знак минус означает выбор всех кроме них


#####минизадание4########
V<-c(9-seq(4,90,4),60,rep(88,15))

#1. выберите первые 10 элементов вектора V
#2. Выберите последние 10 элементов вектора V
#3. Выберите 1-ый, 25-ый и последний элемент вектора V
#4. добавьте к вектору V в конце 3 новых элемента, равных 27, 56 и 98

####Второй вариант используем логический вектор который по длинне РАВЕН исходному вектору
A<-letters
D<-c(rep(TRUE, length.out=10), rep(FALSE,10),rep(TRUE,6)) #rep() - повторяет нужное число раз
D #длинна 26 как и у вектора A

A[D] #первые 10 и последние 6 букв, там где у D стоит TRUE
A=="c" #тоже логический вектор, длинной равной A, поэтому можем использовать для subsetting
A==c #не забываем КОВЫЧКИ
A[A=="c"] #это несколько бесмысслено, но нужно будет когда перейдем к Data.frame 

B<-c("a","k", "о", "c","f","h","rt", "ы")
A[A %in% B] #почему не выбралось о?

A<-(1:500-50)/2
A[A<50&A!=7]
A[!A %in% c(50,130,170)/2]
C<-seq(1,500,20)/2
A[!A %in% C]
length(A)
length(A[!A %in% C])

#с помощью второго способа также можно перезаписывать элементы
A[A %in% C] <- 0 #обнуляем элементы совпадающие с С
A[A == 0] <- A[1] #а теперь присваиваем нулевым значениям, значения первого элемента

#################Домашнее задание###########################
#1.посчитать разность между двумя средними (постарайтесь в одну строчку): 
      #1)среднее от последовательности чисел от 1 до 10000 
      #2) среднее от последовательности чисел от 1 до 500 делящихся на 5


#2. создать логический вектор RE, элемент которого равен TRUE, если элемент последовательности чисел от 10 до 300, делящихся на
  #10 равен 20 ИЛИ 100 и FALSE в противном случае

#3. создать логический вектор Rt, элемент которого равен TRUE, если элемент последовательности ЧЕТНЫХ чисел от 1 до 500 
  #равен какому либо элементу последовательности от 1 до 500 делящихся на 55

#4.создать вектор AB.1 числовой последовательности от 30 (первое значение) до 500 в котором будут только четные числа
#5. переделать этот вектор чтобы значения шли по убыванию
#6. вывести на экран каждое третье значение этого вектора
#7. создать вектор AB.2 равный всем значениям первого вектора меньше 100 и больше 50
#8. у второго вектора вывести на экран 1-ый, 3-ий и 6-ой элементы 
#9. Присвоить всем элементам  вектора AB.2 которые делятся на 3 значаение NA


##########################День 3########################################################

rm(list=ls()) #удаление всех объектов из памяти (Global Environment)


#############Класс Data.frame#################
#Это совокупность векторов одной длинны - фактически это Таблица с данными
hryvna<-c(23.8421,23.9376, 23.7285,23.6641,23.7134)

#создание data.frame с нуля
currency.fx<-data.frame(eur=c(75.5481, 75.5541, 75.3861,	74.6312, 75.1932), 
                        usd=c(66.5499, 66.3318,66.0016,65.9170, 65.9300), 
                        hryvna=hryvna) 
currency<-data.frame() #создание пустой data.frame

currency.fx  

class(currency.fx)
View(currency.fx) #очень полезна если таблица большая
str(currency.fx) #структура объекта
summary(currency.fx)

nrow(currency.fx) #кол-во рядов
ncol(currency.fx) #кол-во колонок
length(currency.fx) #аналогично ncol, но лучше не пользоваться

names(currency.fx) #ВЕКТОР имен колонок (переменных), с ним можно делать все что можно делать с векторами
names(currency.fx)[3] <-"uah" #переименование колонки
names(currency.fx)

row.names(currency.fx) #имена рядов, реже используется
row.names(currency.fx)<-letters [1:5] #переименовываю имя ряда

#######минизадание########
#создайте data frame: Animals из трех рядов и 4 колонок: species, ID, age, Dead. 
#Последняя колонка должна быть logical. Значения придумайте сами



#####Операции с data.frame, только если все столбцы числовые 
#4*currency.fx
#currency.fx-currency.fx/4
#currency.fx*c(1:5) #каждый столбец умножается на этот вектор
#currency.fx*currency.fx 
#currency.fx^2
#max(currency.fx)


##########subseting data.frame#########
ir<-iris #iris презагруженный объект data.frame
View(ir)
str(ir) #обратите внимание на знак доллара

###1 способ - работает только с колонками (переменными) ####
ir$Sepal.Length #на выходе колонка в виде ВЕКТОРА
ir$"Sepal.Length" #это один из немногих случаев когда можно и в ковычках и без ковычек

#с ним можно делать всё что можно с вектором
class(ir$Species)
levels(ir$Species)
ir$Sepal.Length>5

#можно делать и subseting
ir$Sepal.Length[1:10]
ir$Sepal.Length[ir$Sepal.Length<5] <- NA
ir$Sepal.Length[Sepal.Length>5] #распространенная ошибка, забывают во второй раз писать ir$
Sepal.Length <- ir$Sepal.Length #а вот так мы можем создать новый вектор из колонки

ir$Sepal.Length[ir$Species=="setosa"] #все Sepal.Length (чашелистик) для вида setosa. не забываем ковычки
ir$Sepal.Length[ir$Sepal.Length>5 & ir$Sepal.Width<3 & ir$Species=="versicolor"]

ir$Species[ir$Species=="versicolor"] <- "vers" #нельзя, так как факторная переменная, заменяет на NA
ir$Species[is.na(ir$Species)] <- "versicolor" #is.na() - возвращает TRUE тем элементам вектора которые NA


levels(ir$Species)[4]<-"vers" #добавляем новую категорию в факторную переменную
ir$Species[ir$Species=="versicolor"] <-"vers" #теперь можем заменить


#самый удобный способ для создание новой колонки - это как раз через $
ir$Petal.Area<-ir$Petal.Length*ir$Petal.Width
ir$age<-"not known"


#####минизадание: создать вектор Petal_l (не в data.frame, а свободный)  
#равный вектору Petal.Length из  data.frame ir но только БЕЗ вида "virginica" 


#############2 способ -универсальный: два измерения [строки,столбцы]#######
## 2а - порядковые номера
#название колонок не являются первой строкой data.frame
ir[2,5] #вторая строка, 5-я колонка
ir[1:4,4:5] #1-4 строку, 4-5 колонка
ir[c(1,5), c(2,4)] #
ir[nrow(ir),ncol(ir)-1] #предпоследний элемент data.frame

#пустое место на месте строк/колонок означает выбор всех рядов или колонок 
ir[1,] #первый ряд и все колонки  (весь второй ряд)
ir[,c(1,5)] #первая и 5-я колонки, на выходе data.frame!!
ir[,3] #аналогично ir$Petal.Length, результат - вектор!!

#отрицательные числа означают исключение этих порядковых чисел 
ir[,-c(1,5)] #знак минус означает исключая эти порядковые номерa (в данном случае колонок). БЕЗ 1-ой и 5-ой колонки

#Создаем новый data.frame, как результат subsetting
ir_1 <- ir[,-c(1,5)]
class(ir_1) 

ir[-1,] #без первого ряда
ir$Sepal.Length[-c(1,10)] #с векторами тоже самое, просто забыл рассказать в ПРОШЛОМ занятии

ir_1<-ir[1:10,] #создаю новый data.frame из 10 первых рядов старого
str(ir_1)
ir[,ncol(ir)] <- 0 #обнуляю ВСЮ последнюю колонку
ir<-ir[,-ncol(ir)] #удаляю последнюю колонку, перезаписав data.frame

ir[nrow(ir)+1,] <- c(2,4,6,8,"vers",12) #добавление новой строки в конец

ir[nrow(ir)+5,] <- c(0,0,6,0,"vers",0) #добавление новой строки через 4 строки, между ставиться NA
#####минизадание######
#Вывести на экран 5 - 10 и 15 ряды из ir без 3-ей колонки

#####2_б Логический вектор########
#в качестве условия ЧАЩЕ всего логические операции с колонками ТОГО ЖЕ САМОГО data.frame
#условие почти ВСЕГДА используется для рядов

ir[ir$Petal.Length > 4.5,] #выбирает ряды где выполняется условие и все колонки
ir[Petal.Length >4.5,] #пропущено ir$

ir[, names(ir)!="Sepal.Width"] #Значительно РЕЖЕ условие пишется для колонок

#можно миксовать способ 2а и 2б
ir[ir$Petal.Width < 1,1:3] #1-3 колонка, для тех рядов где выполняется условие

ir[ir$Petal.Width < 1,6]<-round(ir[ir$Petal.Width < 1,6],1) #мы переписали данные, округлив их до первого знака

ir[ir$Petal.Width==max(ir$Petal.Width),5] #вид, для которого лепесток имеет наибольшую ширину, 3 случая одинаковой ширины
ir[ir$Petal.Width==max(ir$Petal.Width),5][1] #выбираем первый

#subseting можно делать несколько раз подряд
ir[ir$Petal.Width>mean(ir$Petal.Width),] [1:2,] 

###не забываем subsetting с [] можно ставить слева и таким образом переписывать
ir[ir$Petal.Width==min(ir$Petal.Width),1:3]<-0

######минизадание####################### 
#создать data.frame ir.hr в котором будут все данные ir кроме колонки "Petal.Area" и кроме тех рядов 
#где Petal.Width равен 0.2,  1.3 или 1.6


####2c ВЕКТОР названий колонок/рядов, в КОВЫЧКАХ!!
###
ir[,"Sepal.Width"] #аналогично ir$Sepal.Width
ir[,Sepal.Width] #не забывайте КАВЫЧКИ - а то R думает что это название объекта
a<-"Sepal.Width"
ir[,a] #а вот так можно
ir[,c("Sepal.Width","Species")] #результата Data.frame


ir[,-c("Sepal.Width","Species")] #минус не работает с названиями колонок, только с их порядковыми номерами
ir[,!names(ir) %in% c("Sepal.Width","Species")] #можно так, но это способ 2б 

#c рядами ситуация аналогична, только названия ставятся в другое место 
row.names(ir)
row.names(ir)<-paste(row.names(ir), letters, sep="") #paste() сшивает character вектора
ir[c("2b","9i"),]

#способ 2с можно миксовать с 2a и 2b
ir[ir$Petal.Length <= 3,c("Sepal.Width","Species")]
ir[1:4,c("Sepal.Width","Species")]

######минизадание####
# вывести на экран данные ir для колонок "Petal.Length","Petal.Area" 
#для видов vers 


#####3 вариант - специальные функции для subseting########
head(ir, n=3) #первые 3 ряда - аналогично ir[1:3,]
tail(ir, n=2) # последние 2 ряда - аналогично ir[(nrow(ir)-1):nrow(ir),]
head(ir$Sepal.Length, n=3) #для векторов тоже работает

#subsetting по рядам с логическим сравнением
subset(ir, (Petal.Area<6&Species=="setosa")| Species=="vers") #здесь название колонок БЕЗ КАВЫЧЕК (исключение из правила)

#subset полезен если у тебя множественное сравнение, экономит место, так как не надо каждый раз писать название
# data.frame - сравните аналог 
ir[(ir$Petal.Area<6&ir$Species=="setosa")| ir$Species=="vers",]

subset(ir,Petal.Area<6, select=c(1,5)) #параметр select выбирает колонки
ir5 <- subset(ir,Petal.Area<6, select=c("Species","Sepal.Width","Sepal.Length")) #можно и так, порядок колонок поменялся
ir[ir$Petal.Area<6,c("Species","Sepal.Width","Sepal.Length")]

####нельзя subset, head, tail слева от знака присваивания (поэтому слева только [])
#то есть нельзя перезаписывать
subset(ir, Petal.Area<6) <- 0 #ошибка

#последовательный subsetting
subset(ir, Petal.Area<6)$Species [1:3] 

#вид у которого разница длинной и шириной лепестка была максимальной
subset(ir, (Petal.Length-Petal.Width)==max(Petal.Length-Petal.Width))$Species 

# а его аналог без subset 
ir$Species[(ir$Petal.Length-ir$Petal.Width)==max(ir$Petal.Length-ir$Petal.Width)] #очень много ir$


####минизадание:######### 
#с помощью subset выведете на экран данные (ряд или если несколько, то ряды) 
#из ir когда Petal.Length был минимальным


#################Дошашнее задание 2###########################
data_chick<-ChickWeight #ChickWeight - это одна из предустановленных (built-in) data.frame: вес,возраст,номер цыпленка, номер диеты
str(data_chick)
class(data_chick$Chick)#обратите внимание "ordered"

#1. выберите  данные по цыплятам 13-18 и запишите в датафрейм chick_13_18. 
#Далее в заданиях используйте этот дата фрейм chick_13_18

#2. выведите на экран первые и последние 5 строчек датафрейма без колонки Diet

#3. выведите на экран data.frame ТОЛЬКО c колонками с возрастом и номером цыпленка  и только 
#для случаев веса меньше 100

#4. выведите на экран все данные цыплят для возраста 12

#5. создайте новую переменную в датафрейм: AvSpeed - средняя скорость набора веса (вес/возраст)

#6. как видно скорость для возраста 0 получилась бесконечной, замените для этого возраста 
#значение скорости на NA (вместо inf)

#7. добавьте в датафрейм новую СТРОЧКУ в которой будет средний вес цыпленка 13 за все время, в качестве значения возраста (Time) 
#напишите "average", #обратите внимание что вы таким образом изменили класс вектора Time
 
#################Домашнее задание 3###########################
data_chick<-ChickWeight #работаем снова с ней
summary(data_chick)

#1.среднеквадратичное отклонение веса всех цыплят для возраста 16, округлить до 3 знака

#2. средний вес всех цыплят в возрасте 2 и с диетой не равной 3, округлить до 3 знака

#3 минимальный вес цыпленка для цыплят возраста 6 и с Diet 1 или 4

#4.средний вес всех цыплят в возрасте 14 и весом больше 111 ИЛИ в возрасте 20 и весом равным 199, 
#округлить до 3 знака

#5.какой номер диеты соотвествовал максимальному среднему весу цыплят в возрасте 20

#6. Какой номер цыпленка (Chick) с весом максимально отклоняющемся от среднего в возрасте 8

#7. максимальный (с точки зрения порядка факторов) номер (Chick) цыпленка у которого вес в каком-либо из 
#возрастов был больше 200, но при этом вес при рождении (Time 0) был меньше 40

#################День5#####################
####Запись!
########## Задачи с subseting (не будем рассматривать)
######статистическая операция с результатом subsetting
#разность средних значений ширины лепестка у двух видов
mean(ir$Petal.Width[ir$Species=="vers"]) - mean(ir$Petal.Width[ir$Species=="setosa"])

#максимально значение ширины лепестка у одного из видов для случаев когда длина лепестка меньше среднего
max(subset(ir,Species=="setosa" & Petal.Length < mean(Petal.Length))$Petal.Width)

######узнать делители числа
a<-345667
del<-data.frame(del=1:a, result=a/(1:a))
del[(del$result-round(del$result))==0,]$del #функция round округляет до указанного порядка (по умолчанию до целого)
del[(del$result-round(del$result))==0,1]


############Загрузка и выгрузка данных#####################
getwd() #текущая папка по умолчанию
setwd("C:/R/Teaching/Data") #set working directory - установка папки по умолчанию
#Обратите внимание, что здесь не прямой (как в Windows), а обратный слеш, так как прямой используется как знак деления

#другой способ - использовать двойной прямой слеш
setwd("C:\\R\\Teaching\\Data")

#при загрузке или выгрузки данных, если путь к файлу не указан, то используется путь к папке по умолчанию 

###загрузка csv, функция read.csv2 используется для загрузки csv "российского формата" (где разделители между колонками точки с запятой)
films<-read.csv2(file="film.csv", dec=".") #загружает как data.frame
#параметр dec - какой знак отделяет целые от десятичных, если у вас запятая, то надо использовать ","  

films<-read.csv2(file="C:/R/Teaching/Data/film.csv", dec=".") #можно и весь путь прописать, если не в папке по умолчанию

str(films) #все строковые воспринимает как факторные

films<-read.csv2(file="film.csv", dec=".", stringsAsFactors = FALSE) #
# stringsAsFactors - воспринимать ли строковые переменные как факторы

str(films)

#другой вариант, прописать все классы переменных вручную с помощью параметра colClasses
films<-read.csv2(file="film.csv", dec=".", 
  colClasses = c("integer", "integer", "character", "factor",rep("character",3),"integer","factor"))

str(films)

#создает новый data.frame только из комедий с наградами
comedies<-films[films$Subject=="Comedy"&films$Awards=="Yes", ]

#теперь выгружаем (сохраняем) новую data.frame на диск
write.csv2(comedies, file="Comedies with awards.csv")

##############Задание в классе######################
#сохранить свои данные из Excel в csv(разделитель запятые), загрузить свои данные в R, 
#сделать какой-то subseting - сохранить его в csv,



######Класс объекта list##########
######класс list - список разномастных объектов
###сделаем list с исследованием
data_chick<-ChickWeight #презагруженный data.frame
chick_survey<-list(data=data_chick, authors=c("Anton", "Gosha", "Petya"), 
                   temperature=data.frame(year=c(2016:2018),temp=c(23,25,27)),
                   period="2016-2018", journal="Ecology", Citations=134) 
#первый и третий элемент - data.frame, остальные вектора
str(chick_survey)#показывает разноуровневую картину и как добраться до нужного элемент разного уровня

###subseting
#1 c помощью $ и названия элемента
chick_survey$authors
chick_survey$data$Time #сначала subsetting list а потом data.frame

##2 c помощью двойных квадратных скобок [[]] и ОДНОГО названия либо ОДНОГО порядкового элемента
#по названию
chick_survey[["authors"]]
chick_survey[[authors]] #забыли кавычки

#по порядковому номеру
chick_survey[[3]] # аналог, в двойный скобках только одно измерение - никаких запятых в [[]]

chick_survey[[c("authors","data")]] #когда несколько названий то не работает
chick_survey[[c(3,1)]] # так лучше тоже не делать, а лучше последовательный subseting

#3 если одинарные скобки то выдает не элементы, а list из этих элементов
chick_survey[2] # list из одного элемента
class(chick_survey[2])
class(chick_survey[[2]])


chick_survey[c(1,3)] #list из двух элементов
chick_survey[c("data","temperature")] #то же самое
chick_survey<-chick_survey[-length(chick_survey)]
#последовательный subsetting
chick_survey[[1]] [1,3] #так как chick_survey[[1]] обычная data.frame
a<-mean(chick_survey[[1]]$Time)

##часто list сложные объекты, типа результат регрессии
lm(data_chick$weight~data_chick$Time) #lm() - функция линейной регрессии, ~ знак зависимости
a<-lm(data_chick$weight~data_chick$Time)
str(a) #list из 12 элементов, один из них data.frame -model
str(a$model) #это исходные данные модели
a$fitted.values # 
a$coefficients
str(a$qr$qr)
dimnames(a$qr$qr)[[1]]
###########графики#############################
ir<-iris

##график одной переменной
plot(y=ir$Sepal.Length, x=1:nrow(ir))

##scatter plot
plot(y=ir$Sepal.Length, x=ir$Sepal.Width)

##график из data.frame
plot(ir)
#plot(a)
#вид графика
?plot
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, type="l")
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, type="o")
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, type="b")
#название графика и осей
#параметр main - название графика; sub - дополнительное название; xlab,ylab название осей
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, type="o",
     main="Характеристики чашелистика", sub="Sepal.Length vs Sepal.Width",
     xlab="Ширина, см", ylab="Длинна, см")

#цвет
#параметр col
?par
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, type="o", col="blue",
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, type="o", col=14,
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")

#http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf очень много цветов
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, type="o", col="darkgoldenrod", # в ковычках
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")

#####вид точек и линий
#https://www.statmethods.net/advgraphs/parameters.html   хороший guide

#pch - вид точек, lty - вид линий, lwd - толщина линии
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, type="o", pch=16, lty=2, lwd=2,
     col="darkgoldenrod", # в ковычках
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")

####величина символов
#cex - увеличивает все символы (точки) на графике (по умолчанию cex=1)
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, cex=2,
     type="o", pch=16, lty=2, lwd=2,
     col="darkgoldenrod", # в ковычках
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")

#cex.lab - величину шрифта названия осей, cex.axis - величину шрифта чисел на осях
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, cex=1.5, cex.lab=1.5,cex.axis=1.5,
     type="o", pch=16, lty=2, lwd=2,
     col="darkgoldenrod", # в ковычках
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")

#добавить еще линию
#функция points
points(y=ir$Petal.Length, x=ir$Petal.Width, cex=1.5,
     type="o", pch=17, lwd=2,
     col="darkblue") #не хватает длинны осей

#перестраиваем первый график добавляя параметры xlim и ylim в которых вектор из 2 чисел (начальное, конечное значение)
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, xlim=c(0, max(ir$Sepal.Width,ir$Petal.Width)),
     ylim=c(0, max(ir$Sepal.Length,ir$Petal.Length)),
     cex=1.5, cex.lab=1.5,cex.axis=1.5,
     type="o", pch=16, lty=2, lwd=2,
     col="darkgoldenrod", # в ковычках
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")

points(y=ir$Petal.Length, x=ir$Petal.Width, cex=1.5, cex.lab=1.5,cex.axis=1.5,
       type="o", pch=17, lwd=2,
       col="darkblue")#теперь все ОК

########в качества pch, col и многих других параметров может выступать вектор равный y и x
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, col=1:nrow(ir),
     cex=1.5, type="p", pch=1:25, lty=2, lwd=2,
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")
boxplot(ir$Sepal.Length ~ ir$Species)
plot(ir$Sepal.Length ~ ir$Species)
##теперь засунем в col и pch переменную название вида
as.numeric(ir$Species)
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, col=as.numeric(ir$Species),
     cex=2, type="p", pch=as.numeric(ir$Species), lty=2, lwd=2,
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")

#создаю свои цвета для каждого вида
color<-rep("darkblue", nrow(ir))
color[ir$Species=="setosa"] <- "darkgoldenrod"
color[ir$Species=="versicolor"] <- "deeppink"

plot(y=ir$Sepal.Length, x=ir$Sepal.Width, col=color,
     cex=2, type="p", pch=as.numeric(ir$Species)+15, lty=2, lwd=2, #у нас будет pch 16,17,18
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")

#как сохранять картинку
setwd("C:/R/Teaching/Data") #не забываем папку по умолчанию
png(filename="plot.png")

plot(y=ir$Sepal.Length, x=ir$Sepal.Width, col=color,
       cex=2, type="p", pch=as.numeric(ir$Species)+15, lty=2, lwd=2, #у нас будет pch 16,17,18
       main="Характеристики чашелистика",
       xlab="Ширина, см", ylab="Длинна, см")
dev.off()

#гистограмма
hist(ir$Sepal.Length)
#используются те же параметры par
hist(ir$Sepal.Length, col="blue",
     main="Характеристики чашелистика",
     xlab="Длинна, см", ylab="Кол-во экземпляров")
#важный параметр breaks
hist(ir$Sepal.Length, breaks=50,
     col="blue", main="Характеристики чашелистика",
      xlab="Длинна, см", ylab="Кол-во экземпляров")
hist(ir$Sepal.Length, breaks=c(4,5,6,7,8),
     col="blue", main="Характеристики чашелистика",
     xlab="Длинна, см", ylab="Кол-во экземпляров")
#3D
#устанавливаем пакеты - это надо сделать 1 раз и на всю жизнь! (ну если не сменишь компьютер и т.п)
install.packages("fields")
install.packages("graphics")

#загружаем пакеты в память R, нужно делать кажды раз как запускаешь R
require(fields)
require(graphics)

image.plot(as.image(x=ir[,1:2], Z=ir$Petal.Length, nrow=16,ncol=16),#x здесь это x и y на графике, поэтому data.frame
         col=c('royalblue1','yellow','orange','tomato','red'),xlab='Sepal.Length',ylab='Sepal.Width')


#######минизадание#####
#постройте графики на основе своих данных

########сохранение объекта для дальнейшего использования в R
#мы хотим сохранить объект films, чтобы заново не загружать его из csv
##команда dput
dput(films, file="all films")

rm(list=ls()) #удаление всех объектов из памяти

#dget загружает объект
dget(file="all films")

#чтобы загрузить объект надо использовать знак присвоения
films.all<- dget(file="all films")

###альтернативный способ - функции save/load. можно сразу несколько объектов, а также сложные объекты
#которые dget/dput не берет
levels(films.all$Subject)
fantasy<-films.all[films.all$Subject=="Fantasy",]
popular<-films.all[films.all$Popularity>60,]
save(list=c("fantasy","popular"), file="fantasy_and_popular")

rm(list=ls()) #удаление всех объектов из памяти

load(file="fantasy_and_popular") #сразу загружает в global environment, знак присвоения не нужен




#######ещё полезные функции чтобы не писать все время название data.frame (не )
####with()
ir$new<-with (ir, (eur/uah)*usd+eu) 
with(ir, usd[usd==max(usd)])

####with тоже нельзя слева
with(ir, usd[usd==max(usd)])<-0


#удобно в сочетании с subset
with(subset(ir, usd>66), mean(eur/usd+34*uah)) #расчет для ситуации когда курс доллара больше 66
#а можно так
with(ir[ir$usd>66,], mean(eur/usd+34*uah)) 


#фигурные скобки позволяют выполнить несколько действий в рамках with (используется и рядом других функций)
#with(subset(ir, usd>66), {
#print(mean(eur/usd))  #print - вывод на экран
#print(sd(eur/usd))
#print(max(eur/usd))
#})

####attach - отменяет необходимость писать название data.frame навсегда, пока не напишешь detach
####количество detach должно быть равно количеству attach
attach(ir)
usd/eur
usd[usd==max(usd)]
detach(ir)

usd/eur

#эта функция опасна, так как
# 1.названия некоторых объектов могут совпадать с названиями колонок data.frame
#2.когда atach и detach далеко разнесены можно запутаться
date<-5
attach(ir)
usd[date=="m"] #так как есть объект date,то он его успользует а не ir$date
detach(ir)


########Cливание двух датафреймов
###по строкам (количество колонок должно быть равно)
currency.new<-data.frame(eur=c(76.5481, 77.5541),usd=c(66.6499, 66.4318), date=c("m","t"),
                         uah=c(23,24), eu=c(76.5481, 77.5541)/c(66.6499, 66.4318), new=NA)
ir<-rbind(ir, currency.new) #raw bind - слияние по рядам
ir[nrow(ir)+1,]<-ir[1,]
ir$ffg<-1
###по колонкам (количество строк долно быть равно)
holidays_time<-data.frame(holidays=c(rep("w",5), "h","h"), time=c(10:16))
currency<-cbind(ir,holidays_time) #column bind


#########классы матрицы, таблицы, list#############

######класс матрица - столбы и строки эквивалентны 
mat<-matrix(data = c(1:600), nrow = 30, ncol = 20) #из вектора делается, фактически это вектор уложенный определенным образом  
class(mat)
colnames(mat)<-letters[1:20]
rownames(mat)<-LETTERS[1:30]
mat #букв не хватило для рядов
names(mat) #не работает для матриц так как столбы и строки эквивалентны

##subsetting похож на data.frame
mat[c(1:3),c("a","b")]
mat$a # не работает
mat[mat>50] #выдает вектор

##операции с матрицами
t(mat) #транспонирование

####как переделать data.frame в матрицу и наоборот - 
data_chick<-ChickWeight
data_chick.mat<-data.matrix(data_chick) #data.matrix из data.frame переводит в  matrix
class(data_chick.mat)
str(data_chick.mat)

data_chick.1<-data.frame(data_chick.mat) #перевод матрицы в data.frame
str(data_chick.1) #все перменные в data.frame стали numeric

#####класс table
sum<-summary(data_chick)
str(sum) #не удобно работать, зато красиво
sum
dimnames(sum)
sum[,1]

sum1<-summary(data_chick$weight)
str(sum1) #намного лучше, ecnm attr - names
names(sum1)
sum1[names(sum1)=="1st Qu."] #уже можно вытащить число
sum1.data<-data.frame(t(matrix(sum1))) #перевод в data.frame
names(sum1.data)<-names(sum1)
sum1.data



#######полезные функции для работы с объектами#####
data_chick<-ChickWeight #работаем снова с ней

### unique - оставляет только уникальные значения
unique(data_chick$Chick)

### table - подсчитывает количество повторений различающихся значений 
table(c("M","T","K","M"))
table(data_chick$Chick)
table(data_chick [,c("Chick","Diet")]) #двойное сочетание
tab<-table(data_chick [,c("Chick","Time")])
str(tab) #класс table

tab_chik<-table(data_chick[,c("Chick","Diet","Time")])
tab_chik #трехмерная таблица
str(tab_chik)
dimnames(tab_chik)[[2]] #dimnames - это "имена измерений", является list так как вектора разной длинны
dimnames(tab_chik)$Diet

#### paste - объедининяет множество значений в одну строковую переменную
name<-"Anna"
age<-17
paste(name,"is", age,"years old", sep=" ") #sep - разделитель, в нашем случае пробел

with(data_chick, paste("Maximum weight was", max(weight), "brought by chicken", Chick[weight=max(weight)],
                       "with Diet", Diet[weight=max(weight)], sep=" ")) #sep - разделитель, в нашем случае пробел
data_chick$ID<-paste(data_chick$Chick,data_chick$Time,sep="_")
#####минизадание: напишите фразу "Minimum weight was reached at Time ... by chicken ..." 


###### arrange (функция пакета plyr) сортировка data.frame по одному или нескольким столбцам
#install.packages("plyr") #- так устанавливают пакеты - это нужно делать только один раз
require(plyr) #так запускают пакет, который уже установлен, нужно делать каждую сессию, можно без кавычек
library("plyr") #аналогичная функция, но менее удобная (например нельзя без кавычек)

data_chick<-arrange(data_chick, Chick) #кавычки у Chick можно не писать, заметьте, что Chick - ordered factor и сортируется по  levels
levels(data_chick$Chick) #обратите внимание сортирует согласно уровням факторной переменной
data_chick<-arrange(data_chick, Chick, decreasing = TRUE) #параметр decreasing=TRUE если хочешь по убыванию
data_chick<-arrange(data_chick, Diet, Chick,Time) #сначала по Diet, потом по Chick (внутри каждой Diet)

###range - расброс - min-max
range(data_chick$weight) 

###diff - разность соседних элементов вектора
data_chick_12<-data_chick[data_chick$Chick==12,]
diff(data_chick_12$weight) #фактически это прирост
data_chick_12$diff_weight<-c(NA,diff(data_chick_12$weight)) #0 нужен так как количество прироста на 1 меньше чем кол-во наблюдений
data_chick_12

#####cumsum - кумулятивная сумма
cumsum(1:100) 
cumsum(c(0,data_chick_12$diff_weight[-1]))+data_chick_12$weight[1] #мы востановили вес зная приросты и начальное значение
data_chick_12$weight

##### which.min и which.max - возвращает порядковый номер максимального или минимального элемента
which.min(data_chick$weight)
data_chick$Chick[which.min(data_chick$weight)] #какой цыпленок с минимальным весом
data_chick$Chick[data_chick$weight==min(data_chick$weight)] # это аналог без использования функции - занимает больше места
data_chick_12$Time[which.max(data_chick_12$diff_weight)] #в каком возрасте набрал максимальный вес

######минизадание: в каком возрасте (кроме нуля) у цыпленка 12 была максимальная средняя скорость роста (weight/Time)
with(subset(data_chick_12, Time!=0), Time[which.max(weight/Time)])
###### which возвращает порядковые номера элементов которые TRUE
which(data_chick$weight > 200)
mean (data_chick$Time [which(data_chick$weight > 200) -1]) #средний возраст цыпленка предшествующего возрасту когда он набрал вес больше 200

##### match возвращает порядковые номера 'элементов вектора B,которые совпадают с вектором A
A<-seq(1,100,by=2)
B<-seq(1,50,by=3)
match(A,B) #порядковые номера A которые совпадают с каким-то из элементов из B

###есть две похожие data.frame которые надо по умному слить
data_all<-data.frame(names=c("Masha", "Gosha", "Petya", "Lesha", "Genya", "Galya","Vova", "Misha"),
                     weight=c(50:57))
data_frag<-data.frame(names=c("Galya", "Vova","Gosha", "Genya", "Misha"),
                      height=seq(160,by=3,length.out=5))

#надо добавить данные height из data_frag в data_all
data_all$height<-data_frag$height[match(data_all$names,data_frag$names)]
data_all

#################Задание в классе 3###########################
data_plant<-CO2 #данные - концентрация CO2 (conc) и сколько потребило растение
?CO2

#1. создать list с именем Plants_chilled из двух элементов: (1) - data.frame с именем chilled, в котором будут только данные по chilled  
#растениям, (2) вектор Plants с названиями (Plant) из первого (1) элемента, в нём каждое имя растения должно встречаться 1 раз

#2 добавить в list из первого задания элемент с одним значением character :"Mean concentration of CO2 is ..., Mean uptake is...",
#  где в качестве ... надо вставить расчитанные значения 

#3. сделать data.frame c summary последних двух колонок data_plant (то есть data.frame из 2 строчек) на основе функции summary

#4. вывести таблицу с количеством случаев chilled и nonchilled в data_plant.

#5. Найти имя растения (Plant) у которого был минимальный uptake в nonchilled состоянии (с помощью which.min)

#6. У вас есть информация что в названии растения две первые буквы означает виды: Qn - Quince Shrubs, Qc - Quaking Aspen Trees,
#Mn - Moonbeam Coreopsis, Mc - Miss Kim Lilac. Добавьте новую колонку с названием вида в data_plant, используя функцию match  


#################Домашнее задание 3###########################
trees<-Loblolly #высота деревьев разного возраста
#1. Номер семечка (seed) у которого был минимальный рост в возрасте 25

#2. минимальный возраст ПОСЛЕ которого рост растения превысил 27 
#(то есть в этом возрасте еще не превысил, а в следующем уже превысил)

##дополнительная информация: буквы, кодирующие семечки 
#(предположим это первая буква названия штата из которого семечка)
trees_2<-data.frame (Seed=unique(trees$Seed)[4:10], weight= c(LETTERS [4:9],20))

#3. Порядковый номер в алфавите буквенного кода семечки, которое набрало наибольший вес в возрасте 5 
#(те семечки у которых нет буквенного кода не учитывать)


beaver<-beaver1 #динамика температуры бобра

#4. время (time) максимального изменения температуры бобра 
#(время, когда это максимальное изменение закончилось)

#5. время (time) когда у бобра достигнута четвертая по величине температура тела


