###############День 1###############################################
#####Синтаксис#####

####присваивание значения объекту (если объекта раньше не было он создается)
age.robert<-23

#В названии объекта нельзя употреблять символы +,-, %,#,) ^ и т.д. так как они зарезервированы для другого

A<-2+3 # складываем и создаем А
A<-A^2
A <- 3.14

#вместо <- можно употребить =, но не рекомендуется так как используется и для параметра функции
A=A*10

#Для вывода на экран значения объекта нужно просто написать его имя
A

2+2*(8^6 - 2)/10 #это значение нигде не запоминается так как никуда оно не присвоилось

####функция

A<-log(x=100, base=10) 
A

#название параметров функции можно не писать, сохранив их порядок
log(1024,2)

#или писать параметры в произвольном порядке, но тогда писать их названия
log(base=2, 1024) #так как у функции только два параметра, то писать можно название только одного, а второй R поймет автоматически

#синтаксис некоторых  функции упрощен, например функция справка ?
? log  #справка[1] 10 функции, в функции чаще всего наиболее важные параметры идут вначале - часто у них нет значения по умолчанию

#если не указываешь значение параметра по умолчанию
log(5)

?seq #задает последовательность чисел
seq(from=1, to=50, by=10)
seq() #так как все паарметры по умолчанию
seq(to=50, 1, 10) #здесь мы прописали название только одного параметра, остальные R интерпретировал как они указаны по порядку

# если не указываешь значение параметра не по умолчанию
log()

#другие упрощенные функции
seq(from=1, to=50, by=1) #то же самое можно записать проще
1:50

#ВАЖНО: В качестве значения параметра функции может выступать другая функция или объект
A<-log(1024,4/2)
length(A) #длинна последовательности
B<-seq(from=log(exp(3)), to=A, by=log(A,10))
length(B)

A<-seq(from=log(exp(3)), to=B, by=log(B,10)) #неправильный формат значения параметра

#СЛедующую строку запускать только ОБВЕДЯ ЕЁ
seq(from=log(exp(3)), to=A, by=log(A,10) # здесь забыта скобка, поэтому на консоле +, 
#то есть ожидание продолжения. Два варианта выхода - либо дописать необходимую скобку (в КОНСОЛЕ),
#либо нажать esc (тоже находясь в консоле)

##########Вектор - самый базовый (низший) класс R###########
######Классы векторов
A<-c(1,3,4,6, log(10,10)) #c() - это generic function создает вектор различных классов
A
class(A) #возвращает класс объекта

A<-as.integer(A) #принудительно делает integer
class(A)

A<-as.numeric(A) #принудительно делает numeric

length(A) #длина вектора
class(length(A)) #длина вектора очевидно всегда целое число

B<-numeric(length=10) #создает numeric длинной 10, заполненный нулями
B
B<-numeric() #создает пустой numeric

#Character - строковые переменные, не забываем кавычки
class(class(A))
A<-c("mama","papa","I want to eat 2 times", 2, class(A)) #c() - это generic function
A
class(A)

A<-c(mama,papa,"I want to eat 2 times", 2, class(A)) ##НЕ ЗАБЫВАЙТЕ КАВЫЧКИ

as.numeric(A) #не знает как превратить маму в число

A<-as.character(c(1,3,4,6, log(10,10))) #принудительно делает character
A #появились кавычки
as.numeric(A) #а вот превратить "1" в число смог

#Factor - обратите внимание, функцию можно написать в сколько угодно строк
C<-factor(x=c("first", "third", "forth", "second", "second","first"), 
                  levels=c("first", "second", "third", "forth"), ordered =  TRUE) #параметр ordered позволяет указать что "first"> "second">"third"> "forth" 
C
class(C)
levels(C)
as.numeric(C) #значение становится соответсвующим порядковым номером уровня
as.numeric(levels(C)) # levels(C) - это character

#Logical
D<-c(TRUE, FALSE,FALSE, TRUE) #БЕЗ КАВЫЧЕК TRUE и FALSE это особые слова
D-1 #в алгебраических операциях TRUE=1, FALSE=0
sum(D) #сумма всех элементов вектора

D<-as.logical(c(1,0,0, 0,1)) # и наоборот в логических операциях 1 это TRUE, 0 - FALSE
D

D<-as.logical(c(2,0,0, 4,-1)) # всё что не ноль - TRUE
D

#####Операции с векторами
#Принцип: проводим операцию: каждый элемент первого вектора с таким же по порядку элементом второго вектора
#в идеальном случае длинны векторов должны быть одинаковыми
A<-1:20
B<-seq(21,80,3)
length(A)
length(B)
B-A #+,-,*,/ как будто в Excel складываешь и вычитаешь колонки
B*A
B/A
C<-c(1,3)
A-C #если векторы не равны, то меньший вектор порторяется необходимое количество раз
A-rep(x=C,times=length(A)/2) #rep - повторяет x в течении times раз
A-1
3*A

mean(A) #среднее
sd(A) #среднеквадратичное отклонение
median(A) 
max(A)
min(A)
summary(A)

######Логические операторы
A<-seq(3,60,by=3)
B<-A < 20 #фактически логический оператор - это упрощенная функция
A < sum(1:10)

B<- seq(0,80, length.out = 20)
A
B
A < B #сравнивает каждый элемент вектора с каждым 

A<=20 # меньше равно
A>=20 # больше равно
A==21 #так как = занято, то логическим оператором равно является == (два равно подряд), найди TRUE
B=20 #это просто присвоит вектору значения

D<-A==15
D

A!=21 #!= это неравно

!TRUE # ! меняет TRUE на FALSE и наоборот
!c(TRUE,FALSE,TRUE)

B<-c("mama","papa")
B=="mama" # 

B>50 #больше\меньше считает сумму порядковых значений букв 

C<-factor(x=c("first", "third", "forth", "second", "second","first"), 
          levels=c("first", "second", "third", "forth"), ordered =  TRUE)
C<2 #для factor сравнивание с числом не работает
C=="second"
C<"third" #так как у нас ordered factor мы можем сделать такое сравнение

A==c(9,21) #== с двумя (и более) числами не проходит, берет только первое число для сравнения (9)
sum(A==c(9,21))
A %in% c(9,21) # для одновременного сравнения 
sum(A %in% c(9,21,60))
!A %in% c(9,21) #все элементы A не равные 9 и 21
sum(!A %in% c(9,21))

A<20&A!=9 #& - оператор "и", чтобы результат был TRUE должно быть TRUE и слева и справа от &, иначе FALSE

A<20|A>50  #| - оператор "или", чтобы результат был TRUE должно быть TRUE или слева или справа от |

A %in% c(60,15,21)
A %in% 1:500
A ==60 | A==15 | A==21 # можно написать и так, но это сложнее - больше букв

(A<40|A==51)&(A>10|A==3)&!(A %in% seq(0,60,by=6)) #сначало выполняется то что в скобках

######## Subsetting vector - вычленение из вектора его части. Два варианта

#####Первый вариант - указание порядковых элементов вектора которые нужно выбрать
A<-letters #letters - это зарезервированное название вектора - все буквы ангийского алфавита
A
A[20] #возвращает 20 элемент вектора
A[20:26] #возвращает c 20 по 26 элемент вектора
A[c(2,4,5)] #обязательно нужно с()
A[2,4,5] # так не работает
A[c(2,4,5)] [2] #выполняется последовательно - сначала вычленяет вектор из трех элементов а потом берет второй элемент нового вектора
A[length(A)] #последний элемент вектора A

B<-A[26:1] # задом наперед
С<-letters[seq(2,length(letters),by=2)] #каждая вторая буква

####Второй вариант используем логический вектор который по длинне равен исходному вектору
D<-c(rep(TRUE, length.out=10), rep(FALSE,length.out=10),rep(TRUE,length.out=6)) #rep - повторяет нужное число раз
D #длинна 26 как и у вектора A

A[D] #первые 10 и последние 6 букв
A=="c"
A==c
A[A=="c"] 
A[A<"c"] # использует порядковые номера букв для сравнения
A[A<"k"&A!="a"]
A[!A %in% c("a","k","m")]

B<-c("a","k","f","h","rt")
A[A %in% B[B!= "k"]]


#################Задание в классе 1###########################
#создать вектор от 30 (первое значение) до 500 в котором будут только четные числа

#переделать этот вектор чтобы значения шли по убыванию

#вывести на экран каждое третье значение этого вектора

#создать второй вектор равный всем значениям первого вектора меньше 100 и больше 50

#у второго вектора вывести на экран 1, 3 и 6 значение по порядку  

#переделать второй вектор в логический (logical) вектор в котором  
#всем его значениям делящимся на 10 присваивается TRUE, а остальным FALSE

###################Домашнее задание 1###############################
#1. найдите сумму всех четных натуральных чисел меньше 10001

#2. посчитайте количество натуральных чисел меньше 10001, которые делятся на 3 и при этом не делятся на 2

##3. Сумма  натуральных чисел от  от 1 до 100000, которые делятся на 13 и 17, но не делятся на 2
#для решения достаточно изученных знаний и функций, но можно также использовать функцию floor 

#4. посчитайте количество четных чисел меньше 10001, когда сумма этого числа 
#с предшествующим ему нечетным числом делится на 3

###################################День 2###############################################
rm(list=ls()) #удаление всех объектов из памяти
#####добавка про вектора
#####с помощью subseting можно менять значения нужных вам элементов вектора
a<-seq(0,100000,length.out = 51) #51 элемент
a[5]<-5000 #изменили 5 по порядку элемент
a[a>90000]<-0 #обнулили все кто больше 90000
a
####можно subseting с обоих сторон
#a[seq(1, length(a), by=2)]<-a[seq(2, length(a), by=2)] #я хотел все значения нечетных элементов заменить 
#значениями стоящих рядом четных элементов, но длинна векторов оказалась неодинаковая
#length(a[seq(1, length(a), by=2)])
#length(a[seq(2, length(a), by=2)])
#a[seq(3, length(a), by=2)]<-a[seq(2, length(a), by=2)] #смогли, только 1 элемент остался неизмененным
#a
#a[length(a):(length(a)-3)]<-mean(a[1:(length(a)-4)]) #заменил последние 4 элемента (нули) средним от остальных элементов
#a
#####добавить элемент в конец вектора
a[length(a)+1]<-100000
a[67]<-7 
#у нас было в a всего 52 элемента, а мы сразу добавили 67, поэтому между 53-66: NA 
a<-c(a[1:59],79,a[60:67])

####минизадание - присвойте 5-ому,10-ому и 13-ому элементам вектора a значения 3, 56, 77.5 

#############Класс Data.frame#################
#Это совокупность векторов одной длинны - фактически это Таблица с данными
hryvna<-c(23.8421,23.9376, 23.7285,23.6641,23.7134)
currency.fx<-data.frame(eur=c(75.5481, 75.5541, 75.3861,	74.6312, 75.1932), 
                        usd=c(66.5499, 66.3318,66.0016,65.9170, 65.9300), 
                        hryvna=hryvna)
currency.fx  
class(currency.fx)
View(currency.fx) #очень полезна если таблица большая
str(currency.fx) #структура объекта
summary(currency.fx)
nrow(currency.fx) #кол-во рядов
ncol(currency.fx) #кол-во колонок
names(currency.fx) #имена колонок (переменных) - атрибут data.frame - это ВЕКТОР, с ним можно делать все что можно делать с векторами
names(currency.fx)[3] <-"uah" #переименование колонки
names(currency.fx)

#row.names(currency.fx) #имена рядов, редко используется
#row.names(currency.fx)<-letters [1:5] #переименовываю имя ряда


#####Операции с data.frame, только если все столбцы числовые 
#4*currency.fx
#currency.fx-currency.fx/4
#currency.fx*c(1:5) #каждый столбец умножается на этот вектор
#currency.fx*currency.fx 
#currency.fx^2
#max(currency.fx)

##########subseting data.frame
###1 способ - работает только с колонками (переменными) 
currency.fx$uah #вытаскивает переменную

#создание новой колонки
nrow(currency.fx)
currency.fx$date<-c("m","t","w","th","fr","sa") #длинна вектора больше чем у data.frame
currency.fx$date<-c("m","t","w","th","fr") # а здесь все ок - длина совпадает
#4*currency.fx #уже нельзя так как один столбец это character
currency.fx$eu<-currency.fx$eur/currency.fx$usd

currency.fx$eur [1:3] #так как это обычный вектор, то его можно тоже subset - см. разделы про вектора 
currency.fx$eur[currency.fx$eur<75.5]
currency.fx$eur[eur<75.5] #ошибка, так как объекта eur нет, а есть объект  currency.fx$eur
currency.fx$eur[currency.fx$usd>66] #выводятся те курсы евро, когда доллар был выше 66 рублей 
#currency.fx$eur[currency.fx$usd>66&currency.fx$uah<23.8]
currency.fx$eur[currency.fx$date=="m"]<-77.4 #мы переписали данные у этого вектора для понедельника

#####минизадание: создать вектор usd_w равный вектору usd из currency.fx при условии date не равен "t" 


###2 способ -универсальный
## 2а - порядковые номера или TRUE/FALSE - как subsetting у векторов, НО - два измерения (строки/столбцы)
currency.fx[2,5] #вторая строка, 5-я колонка
currency.fx[2:4,4:5]
currency.fx[c(1,5), c(2,4)]
currency.fx[nrow(currency.fx),ncol(currency.fx)-1] #предпоследний элемент data.frame

#пустое место на месте i или j означает выбор всех рядов или колонок 
currency.fx[2,] #второй ряд и все колонки  (весь второй ряд)
currency.fx[,c(1,5)] #первая и 5-я колонки
currency.fx[,3] #аналогично currency.fx$uah

currency.fx[,-c(1,5)] #знак минус означает исключая эти порядковые номерa (в данном случае колонок)
currency.fx[-1,] #без первого ряда

#условия
currency.fx[currency.fx$usd>66,] #условие почти всегда используется для рядов
currency.fx[usd>66,] #объекта usd нет а есть currency.fx$usd

#currency.fx[currency.fx$usd>66|currency.fx$date=="m", names(currency.fx)!="usd"] #полезное условие для колонок придумать сложнее, но можно
currency.fx[currency.fx$date=="t",1:3]<-round(currency.fx[currency.fx$date=="t",1:3],1) #мы переписали данные, округлив их до первого знака

currency.fx[currency.fx$usd==max(currency.fx$usd),4] #дата, когда курс доллара был максимален
#currency.fx[currency.fx$usd==max(currency.fx$usd),]

#subseting можно делать несколько раз подряд
currency.NA<-currency.fx[currency.fx$usd>65.4,] [1:2,] 
#currency.NA
#NA -missing values он выдал, так как после первого условия у нас оставалось 2 строчки, а я во втором subsetting выбрал четыре строчки
#is.na(currency.NA) #проверка на NA
#currency.NA[!is.na(currency.NA$eur)&!is.na(currency.NA$usd),] #исключение строчек в которой есть NA

#currency.NA<-NULL #таким образом мы обнулили (опустошили) объект, NULL часто появляется, когда на выходe функции получается пустой объект  
#class(currency.NA)
#is.null(currency.NA)

###не забываем subsetting с [] можно ставить слева и таким образом переписывать
currency.fx[currency.fx$usd==65.9300,5]<-NA

######минизадание создать data.frame currency.hr в котором будут все данные currency.fx кроме тех, 
#где uah равен 23.9000 или 23.6641


####2b название колонок/рядов
currency.fx[,"uah"] #аналогично currency.fx$uah
currency.fx[,usd] #не забывайте КАВЫЧКИ - а то R думает что это название объекта
a<-"usd"
currency.fx[,a] #а вот так можно
currency.fx[,c("date","uah")]

#currency.fx[c("a","c"),c("date","uah")] 
currency.fx[,-c("date","uah")] #минус не работает с названиями колонок, только с их порядковыми номерами
currency.fx[,!names(currency.fx) %in% c("date","uah")] #можно так

currency.uah <- currency.fx[,c("date","uah")] #не забываем что во всех приведенных выше случаях, 
#все что выведено на экран можно вместо этого записать как новый объект
#currency.uah 

######минизадание: вывести на экран данные currency.fx для колонок "usd","hryvna" 
#для случая когда eu больше 1.135


#####третий вариант - специальные функции для subseting
head(currency.fx, n=3) #первые 3 ряда - аналогично currency.fx[1:3,]
tail(currency.fx, n=2) # последние 2 ряда - аналогично currency.fx[(nrow(currency.fx)-1):nrow(currency.fx),]
head(currency.fx$usd, n=3) #для векторов тоже работает

#subsetting по рядам
subset(currency.fx, (usd<66.5&eur>75.2)| date=="t") #здесь название колонок БЕЗ КАВЫЧЕК (исключение из правила)
#subset полезен если у тебя множественное сравнение, экономит место, так как не надо каждый раз писать название
# data.frame - сравните аналог 
currency.fx[(currency.fx$usd<66.5&currency.fx$eur>75.2)| currency.fx$date=="t",]

####нельзя subset, head, tail слева от знака присваивания (поэтому слева только [])
subset(currency.fx, (usd<66.5) <- 0 #ошибка

#последовательный subsetting
subset(currency.fx, usd>65.8)$usd # курс доллара для случаев когда курс был больше 66

subset(currency.fx, (eur-usd)==max(eur-usd))$date #дата когда разница между курсами была максимальной

# а его аналог без subset 
currency.fx$date[(currency.fx$eur-currency.fx$usd)==max(currency.fx$eur-currency.fx$usd)]

###минизадание: с помощью subset выведете на экран данные (ряд) 
#из currency.fx когда курс евро был максимальным



#######ещё полезные функции чтобы не писать все время название data.frame (не )
####with()
currency.fx$new<-with (currency.fx, (eur/uah)*usd+eu) 
with(currency.fx, usd[usd==max(usd)])

####with тоже нельзя слева
with(currency.fx, usd[usd==max(usd)])<-0


#удобно в сочетании с subset
with(subset(currency.fx, usd>66), mean(eur/usd+34*uah)) #расчет для ситуации когда курс доллара больше 66
#а можно так
with(currency.fx[currency.fx$usd>66,], mean(eur/usd+34*uah)) 


#фигурные скобки позволяют выполнить несколько действий в рамках with (используется и рядом других функций)
#with(subset(currency.fx, usd>66), {
  #print(mean(eur/usd))  #print - вывод на экран
  #print(sd(eur/usd))
  #print(max(eur/usd))
  #})

####attach - отменяет необходимость писать название data.frame навсегда, пока не напишешь detach
####количество detach должно быть равно количеству attach
attach(currency.fx)
usd/eur
usd[usd==max(usd)]
detach(currency.fx)

usd/eur

#эта функция опасна, так как
# 1.названия некоторых объектов могут совпадать с названиями колонок data.frame
#2.когда atach и detach далеко разнесены можно запутаться
date<-5
attach(currency.fx)
usd[date=="m"] #так как есть объект date,то он его успользует а не currency.fx$date
detach(currency.fx)


########Cливание двух датафреймов
###по строкам (количество колонок должно быть равно)
currency.new<-data.frame(eur=c(76.5481, 77.5541),usd=c(66.6499, 66.4318), date=c("m","t"),
               uah=c(23,24), eu=c(76.5481, 77.5541)/c(66.6499, 66.4318), new=NA)
currency.fx<-rbind(currency.fx, currency.new) #raw bind - слияние по рядам


###по колонкам (количество строк долно быть равно)
holidays_time<-data.frame(holidays=c(rep("w",5), "h","h"), time=c(10:16))
currency<-cbind(currency.fx,holidays_time) #column bind


########## Задача - узнать делители числа
a<-11873
del<-data.frame(del=1:a, result=a/(1:a))
del[(del$result-round(del$result))==0,]$del #функция round округляет до указанного порядка (по умолчанию до целого)
del[(del$result-round(del$result))==0,1]

#################Задание в классе 2###########################
data_chick<-ChickWeight #ChickWeight - это одна из предустановленных (built-in) data.frame: вес,возраст,номер цыпленка, номер диеты
str(data_chick)
#1. выберите  данные по цыплятам 13-18 и запишите в датафрейм chick_13_18. 
#Далее в заданиях используйте этот дата фрейм chick_13_18

#2. выведите на экран первые и последние 5 строчек датафрейма без колонки Diet

#3. выведите на экран data.frame ТОЛЬКО c колонками с возрастом и номером цыпленка  и только 
#для случаев веса меньше 100

#4. выведите на экран все данные цыплят для возраста 12

#5. создайте новую переменную в датафрейм AvSpeed - средняя скорость набора веса (вес/возраст)

#6. как видно скорость для возраста 0 получилась бесконечной, замените для этого возраста 
#значение скорости на NA (вместо inf)

#7. добавьте в датафрейм новую строчку в которой будет средний вес цыпленка 13 за все время, в качестве значения возраста напишите "average"
#обратите внимание что вы таким образом изменили класс вектора Time
 
#################Домашнее задание 2###########################
data_chick<-ChickWeight #работаем снова с ней
summary(data_chick)

#1.среднеквадратичное отклонение веса всех цыплят для возраста 16, округлить до 3 знака

#2. средний вес всех цыплят в возрасте 2 и с диетой не равной 3, округлить до 3 знака

#3 минимальный вес цыпленка для цыплят возраста 6 и с Diet 1 или 4

#4.средний вес всех цыпляте в возрасте 14 и весом больше 111 ИЛИ в возрасте 20 и весом равным 199, 
#округлить до 3 знака

#5.какой номер диеты соотвествовал максимальному среднему весу цыплят в возрасте 20

#6. Какой номер цыпленка (Chick) с весом максимально отклоняющемся от среднего в возрасте 8

#7. максимальный (с точки зрения порядка факторов) номер (Chick) цыпленка у которого вес в каком-либо из 
#возрастов был больше 200, но при этом вес при рождении (Time 0) был меньше 40

#########классы матрицы, таблицы, list#############

######класс матрица - столбы и строки эквивалентны 
mat<-matrix(data = c(1:600), nrow = 30, ncol = 20) #из вектора делается  
class(mat)
colnames(mat)<-letters[1:20]
rownames(mat)<-LETTERS[1:30]
mat #букв не хватило для рядов
names(mat) #не работает для матриц так как столбы и строки эквивалентны

##subsetting похож на data.frame
mat[c(1:3),c("a","b")]
mat$a # не работает
mat[mat>50] #выдает вектор

##операции с матрицами
t(mat) #транспонирование
data_chick<-ChickWeight
str(t(data_chick)) # с data.frame тоже можно, но результатом будет вектор

####как переделать data.frame в матрицу и наоборот - 
data_chick.mat<-data.matrix(data_chick) #data.matrix из data.frame в  matrix
class(data_chick.mat)
str(data_chick.mat)

data_chick.1<-data.frame(data_chick.mat)
str(data_chick.1) #все перменные в data.frame стали numeric
str(data_chick)

#####класс table
sum<-summary(data_chick)
str(sum) #не удобно работать, зато красиво
sum
dimnames(sum)
sum[,1]

sum1<-summary(data_chick$weight)
str(sum1) #намного лучше
sum1[names(sum1)=="1st Qu."]/3 #уже можно вытащить число
sum1.data<-data.frame(t(matrix(sum1)))
names(sum1.data)<-names(sum1)
sum1.data

######класс list - список разномастных объектов
###сделаем list с исследованием
chick_survey<-list(data=data_chick, authors=c("Anton", "Gosha", "Petya"), 
                   temperature=data.frame(year=c(2016:2018),temp=c(23,25,27)),
                   period="2016-2018", journal="Ecology", Citations=134)
str(chick_survey)
###subseting
chick_survey$authors
chick_survey[[2]]
chick_survey[2] #а если так то выдаст list одного элемента
str(chick_survey[2])
chick_survey[c(1,3)] #список из двух элементов
chick_survey[[c(1,3)]]
str(chick_survey[[c(1,3)]]) #не вразумительное что-то

chick_survey[[1]] [1,3] #так как chick_survey[[1]] обычная матрица
chick_survey[[1]]$Time

###элементом list может быть list
chick_survey$reviews<-list(result="accepted", 
                           marks=data.frame(reviewers=c("Vova","Petya","Dasha"), marks=c(7,8,6)))
str(chick_survey)
chick_survey$reviews$result

##часто list сложные объекты, типа результат регрессии
lm(data_chick$weight~data_chick$Time)
a<-lm(data_chick$weight~data_chick$Time)
str(a) #list из 12 элементов, один из них data.frame -model
str(a$model) #это исходные данные модели
a$model$"data_chick$weight" #"data_chick$weight" - это название переменной, поэтому в кавычках


#######полезные функции для работы с объектами#####
data_chick<-ChickWeight #работаем снова с ней

### unique - оставляет только уникальные значения
unique(data_chick$Chick)

### table - подсчитывает количество повторений различающихся значений 
table(data_chick$Chick)
table(data_chick [,c("Chick","Diet")]) #двойное сочетание
tab<-table(data_chick [,c("Chick","Diet")])
str(tab) #класс table

tab_chik<-table(data_chick[,c("Chick","Diet","Time")])
tab_chik #трехмерная таблица
str(tab_chik)
dimnames(tab_chik)[[2]] #dimnames - это list так как вектора разной длинны


#### paste - объедининяет множество значений в одну строковую переменную
with(data_chick, paste("Maximum weight was", max(weight), "brought by chicken", Chick[weight=max(weight)],
                       "with Diet", Diet[weight=max(weight)], sep=" ")) #sep - разделитель, в нашем случае пробел

###### arrange (функция пакета plyr) сортировка data.frame по одному или нескольким столбцам
#install.packages("plyr") - так устанавливают пакеты - это нужно делать только один раз
require(plyr) #так запускают пакет, который уже установлен, нужно делать каждую сессию, можно без кавычек,

arrange(data_chick, Chick) #кавычки у Chick можно не писать, заметьте, что Chick - ordered factor и сортируется по  levels
levels(data_chick$Chick)
arrange(data_chick, Chick, decreasing = TRUE) #параметр decreasing=TRUE если хочешь по убыванию

arrange(data_chick, Diet, Chick) #сначала по Diet, потом по Chick (внутри каждой Diet)



###range - расброс - min-max
range(data_chick$weight) 

###diff - разность соседних элементов вектора
data_chick_12<-data_chick[data_chick$Chick==12,]
diff(data_chick_12$weight) #фактически это прирост
data_chick_12$diff_weight<-c(0,diff(data_chick_12$weight)) #0 нужен так как количество прироста на 1 меньше чем кол-во наблюдений
data_chick_12

#####cumsum - кумулятивная сумма
cumsum(1:1000) 
cumsum(data_chick_12$diff_weight)+data_chick_12$weight[1] #мы востановили вес зная приросты и начальное значение
data_chick_12$weight

##### which.min и which.max - возвращает порядковый номер максимального или минимального элемента
which.min(data_chick$weight)
data_chick$Chick[which.min(data_chick$weight)] #какой цыпленок с минимальным весом
data_chick_12$Time[which.max(data_chick_12$diff_weight)] #в каком возрасте набрал максимальный вес

###### which возвращает порядковые номера элементов которые TRUE
which(data_chick$weight > 200)
mean (data_chick$Time [which(data_chick$weight > 200) -1]) #средний возраст цыпленка предшествующего возрасту когда он набрал вес больше 200

##### match возвращает порядковые номера 'элементов вектора A,которые совпадают с вектором B
###есть две похожие data.frame которые надо по умному слить
data_all<-data.frame(names=c("Masha", "Gosha", "Petya", "Lesha", "Genya", "Galya","Vova", "Misha"),
                     weight=c(50:57))
data_frag<-data.frame(names=c("Galya", "Vova","Gosha", "Genya", "Misha"),
                      height=seq(160,by=3,length.out=5))

#надо добавить данные data_frag в data_all
data_all$height<-data_frag$height[match(data_all$names,data_frag$names)]
data_all

#################Задание в классе 3###########################
data_plant<-CO2 #данные - концентрация CO2 (conc) и сколько потребило растение
?CO2

#1. создать list из двух элементов: (1) - data.frame в котором будут только данные по chilled  
#растениям, (2) вектор с названиями (Plant) из первого (1) элемента, в нём каждое имя растения должно встречаться 1 раз

#2 добавить в list из первого задания элемент с одним значением character :"Mean concentration of CO2 is ..., Mean uptake is...",
#  где в качестве ... надо вставить расчитанные значения 

#3. сделать data.frame c summary последних двух колонок data_plant (то есть data.frame из 2 строчек) на основе функции summary

#4. вывести таблицу с количеством случаев chilled и nonchilled в data_plant.

#5. Найти имя растения (Plant) у которого был минимальный uptake в nonchilled состоянии

#6. У вас есть информация что в названии растения две первые буквы означает виды: Qn - Quince Shrubs, Qc - Quaking Aspen Trees,
#Mn - Moonbeam Coreopsis, Mc - Miss Kim Lilac. Добавьте новую колонку с названием вида в data_plant, используя функцию match  


#################Домашнее задание 3###########################
trees<-Loblolly #высота деревьев разного возраста
#1. Номер семечка (seed) у которого был минимальный рост в возрасте 25

#2. минимальный возраст ПОСЛЕ которого рост растения превысил 27

##дополнительная информация о букве, кодирующей семечко семечка
trees_2<-data.frame (Seed=unique(trees$Seed)[4:10], weight= c(LETTERS [4:9],20))

#3. Порядковый номер в алфавите семечки, которое набрало наибольший вес в возрасте 5 (те семечки у которых нет букв не учитывать)


beaver<-beaver1 #динамика температуры бобра

#4. конечное время (time) максимального изменения температуры бобра

#5. время когда у бобра достигнута четвертая по величине температура тела


