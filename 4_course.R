###############День 1###############################################
#####Синтаксис#####

####присваивание значения объекту (если объекта раньше не было он создается)
age.robert <- 23

#В названии объекта нельзя употреблять символы +,-, %,#,) ^ и т.д. так как они зарезервированы для другого

A<-2+3 # складываем и создаем А
A<-A^2 #изменяем A с помощью самого A
A <- 3.14


#вместо <- можно употребить =, но не рекомендуется так как используется и для параметра функции
A=A*10

#Для вывода на экран значения объекта нужно просто написать его имя
A
A^0.5 #объект никак не создается и не изменяется так как нет знака присваивания
2+2*(8^6 - 2)/10 #это значение нигде не запоминается так как никуда оно не присвоилось

####функция
#+ - это оператор, сокращенный вариант функции sum()
2+2
sum(2,2)

A<-log(x=100, base=10) 
A

#название параметров функции можно не писать, сохранив их порядок
log(1024,2)

#или писать параметры в произвольном порядке, но тогда писать их названия
log(base=2, 1024) #так как у функции только два параметра, то писать можно название только одного, а второй R поймет автоматически

#синтаксис некоторых  функции упрощен, например функция справка ?
?log  #справка функции, в функции чаще всего наиболее важные параметры идут вначале - часто у них нет значения по умолчанию

#если не указываешь значение параметра по умолчанию
log(5) #по умолнчанию основание логарифма экспонента (натуральный логарифм)

?seq #задает последовательность чисел
seq(from=1, to=50, by=10)
seq() #так как все параметры по умолчанию есть
seq(to=50, 1, 10) #здесь мы прописали название только одного параметра, остальные R интерпретировал как они указаны по порядку

# если не указываешь значение параметра, у которого нет значения по умолчанию, то ошибка
log()

#упрощенные функции
seq(from=1, to=50, by=1) #то же самое можно записать проще
1:50 #: - это оператор

#ВАЖНО: В качестве значения параметра функции может выступать другая функция или объект
A<-log(2048,4/2)
length(A) #длинна последовательности
B<-seq(from=log(exp(3)), to=A, by=log(A,10))
length(B)
sum(B) #сумма элементов последовательности

A<-seq(from=log(exp(3)), to=B, by=log(B,10)) #неправильный формат значения параметра

#функция ВСЕГДА стоит справа от знака присваивания
seq(from=1, to=1000, by=5)  <- 56
seq(from=1, to=1000, by=5)  <- B

#СЛедующую строку запускать только ОБВЕДЯ ЕЁ
seq(from=log(exp(3)), to=A, by=log(A,10) # здесь забыта скобка, поэтому на консоле +, 
#то есть ожидание продолжения. Два варианта выхода - либо дописать необходимую скобку (в КОНСОЛЕ),
#либо нажать esc (тоже находясь в консоле)

########минизадание_1#########
#записать в объект Ab_3 последовательность всех четных чисел внутри числового промежутка от 1 до 10000 
#вычислить и вывести на экран логарифм по основанию 2 каждого элемента объекта Ab_3


##########Вектор - самый базовый (низший) класс объектов R###########
######Классы векторов
a <- 1 #число 1 это тоже вектор
length(a)

####Numeric and integer
A<-c(1,3,4,6, log(10,10)) #c() - это generic function создает вектора различных классов (см ниже). в данном случае мы создали вектов класса numeric
A
class(A) #возвращает класс объекта

A<-as.integer(A) #принудительно делает integer
class(A)

A<-as.numeric(A) #принудительно делает numeric

length(A) #длина вектора
class(length(A)) #длина вектора очевидно всегда целое число

B<-numeric(length=10) #создает numeric длинной 10, заполненный нулями
B
B<-numeric() #создает пустой numeric

#####Character - строковые переменные, не забываем кавычки
D <- class(A)
class(D)
A<-c("mama","papa","I want to eat 2 times", 2, class(A)) #c() - это generic function
A #обратите внимания 2 в ковычках, хотя в "I want to eat 2 times" несколько слов - это 1 элемент вектора, 
#в одном элементе вектора сharacter может быть "сколь угодно" слов, , букв, предложений 

class(A)

A<-c(mama,papa,"I want to eat 2 times", 2, class(A)) ##НЕ ЗАБЫВАЙТЕ КАВЫЧКИ

as.numeric(A) #не знает как превратить "маму" в число, NA - специальный символ, обозначающий “нет значения” (от NOT AVAILABLE)

A<-as.character(c(1,3,4,6, log(10,10))) #принудительно делает character
A #появились кавычки

as.numeric(A) #а вот превратить "1" в число смог

#в одном элементе вектора сharacter может быть "сколь угодно" слов, , букв, предложений,строк 
#запятые в ковычках не видятся функцией как переход к новому параметру 
Puchkin<-c("Пушкин", "Мороз и солнце; день чудесный!
             Еще ты дремлешь, друг прелестный -
             Пора, красавица, проснись:
             Открой сомкнуты негой взоры
           Навстречу северной Авроры,
           Звездою севера явись!")

#######Factor - вектор для обозначения категорий, обратите внимание, функцию можно написать в сколько угодно строк
C<-factor(x=c("first", "third", "forth", "second", "second","first"), 
                  levels=c("first", "second", "third", "forth", "fifth"), ordered =  TRUE) #параметр ordered позволяет указать что "first"> "second">"third"> "forth" 
C
class(C)
levels(C)
as.numeric(C) #значение становится соответсвующим порядковым номером уровня
as.numeric(levels(C)) # так как levels(C) - это character, а не factor

#######Logical
D<-c(TRUE, FALSE,FALSE, TRUE) #БЕЗ КАВЫЧЕК TRUE и FALSE это особые слова
D-1 #в алгебраических операциях TRUE=1, FALSE=0
#выясняем сколько TRUE в векторе
sum(D) #sum() - сумма всех элементов вектора

D<-as.logical(c(1,0,0, 0,1)) # и наоборот в логических операциях 1 это TRUE, 0 - FALSE
D

D<-as.logical(c(2,0,0, 4,-1)) # всё что не ноль - TRUE
D

########минизадание_2#######
#создать числовой вектор Big.data в котором будет последовательность чисел от 500 до 10000
#создать вектор character с именем ABCDEF в котором будут 6 элементов - первые 6 заглавных букв английского алфавита
#создать вектор factor с именем ABC в котором будет 6 элементов, каждый из которых одна из 3 первых букв английского алфавита 
#(в произвольной последовательности), при этом установить order, где первая буква алфавита БОЛЬШЕ второй, а вторая больше третьей

#########День 2#################
#####Операции с векторами
#Принцип: проводим операцию: каждый элемент первого вектора с таким же по порядку элементом второго вектора
#в идеальном случае длинны векторов должны быть одинаковыми
A<-1:20
B<-seq(21,80,3)
length(A)
length(B)
B-A #+,-,*,/ как будто в Excel складываешь и вычитаешь колонки
B*A
B/A
C<-c(1,3)
A-C #если векторы не равны, то меньший вектор порторяется необходимое количество раз
A-rep(x=C,times=length(A)/length(C)) #rep() - повторяет x в течении times раз
A-1
3*A # число 3 это тоже вектор длинной 1

mean(A) #среднее элементов векторов
sd(A) #среднеквадратичное отклонение
median(A) 
max(A)
min(A)
summary(A)
class(summary(A))
class(min(A))

#######использование функции с()########

##функция с() ОБЪЕДИНЯЕТ несколько векторов в один. Помните: Одно число - это тоже вектор

a<-c(4,1:50, seq(1,90,7), 40) #здесь объединяются 4 вектора
b<-c(a,seq(1,90)/4) #здесь объединяются 2 вектора


##На выходе 1) функции seq() (и многих других функций), 2) арифметических и логических операций с векторами
#получается вектор. Помните НИЧЕГО ниже вектора в R нет. Поэтому простое добавление с() бессмысленно и 
#загромождает код
a<-c(seq(3,50,4)) #НЕПРАВИЛЬНО
a<-seq(30,50,4) #Правильно




#####минизадание_3######
#1 создать вектор M как результат разности между последовательностью четных чисел и нечетных чисел от 4 до 51
#2 найти сумму элементов вектора M


######Логические операторы####
A <- seq(3,60,by=3)
A < 20 #каждый элемент вектора A сравнивается с 20 (меньший вектор повторяется необходимое число раз), 
#и если больше, то записывает вместо этого элемента FALSE, если меньше TRUE. 
#То есть на выходе логический вектор длинна которого равна А, 

B <- A < 20 #фактически логический оператор - это упрощенная функция
A < max(1:6) #не путайте < (меньше) и <- (знак присваивания)

B<- seq(0,80, length.out = 20) #length.out определяет кол-во элементов равномерно распределенных между 0 и 80
A
B
A < B #сравнивает каждый элемент вектора A с соответсвующим по счету элементом вектора B  
A < seq(9,14,by=2) #повторяет меньший вектор необходимое число раз

A <= 20 # меньше равно
A >= 20 # больше равно
A == 21 #так как = занято, то логическим оператором равно является == (два равно подряд), найди TRUE
length(A) == length(B)
B = 20 #это просто присвоит вектору значение (аналог <-), лучше не пользоваться, а то тяжело читать код

D <- A == 15
D

A != 21 #!= это неравно, а теперь найди FALSE

!TRUE # ! меняет TRUE на FALSE и наоборот
!c(TRUE,FALSE,TRUE)

!A < 15 #
A >= 15 #аналог 

!(A<15) #можно в скобках, но они избыточны, старайтесь избегать где можно

C<-factor(x=c("first", "third", "forth", "second", "second","first"), 
          levels=c("first", "second", "third", "forth"), ordered =  TRUE)

C<2 #для factor сравнивание с числом не работает
!C=="second" #это работает и для вектора character
C<"third" #так как у нас ordered factor мы можем сделать такое сравнение


A==c(9,21) #== с двумя (и более) числами не проходит, берет только первое число для сравнения (9)
sum(A==c(9,21)) #sum очень удобно для выяснения кол-ва TRUE

A %in% c(9,21) # для одновременного сравнения с несколькими числами (элементами)
sum(A %in% c(9,21,60))
!A %in% c(9,21) #все элементы A не равные 9 и 21
!(A %in% c(9,21)) #если очень некомфортно, то можно скобки в сложных выражениях
sum(!A %in% c(9,21))

K<-c("second", "forth")#character вектор
C %in% K #факторный вектор сравнивается с сharacter вектором. Это нормально


A<20 & A!=9 # & - оператор "и", чтобы результат был TRUE должно быть TRUE и слева и справа от &, иначе FALSE

A<20|A>50  # | - оператор "или", чтобы результат был TRUE должно быть TRUE или слева или справа от |

A %in% c(60,15,21)
A ==60 | A==15 | A==21 # можно написать и так, но это сложнее - больше букв

(A<40|A==51)&(A>10|A==3)&!A %in% seq(0,60,by=6) #сначало выполняется то что в скобках


g<-c(a<50,a>80) #здесь объединяются два логических вектора a<50 и  b>80, не путать с a<50&b>80

b<-c(a<40 & !a %in% seq(1,40,3)) #НЕПРАВИЛЬНО стилистически, добавление с() бесмысленно
b<-a<40 & !a %in% seq(1,40,3)    #тот же ответ но меньше скобок

######минизадание 4#####
#1.создать логический вектор Re, элемент которого равен TRUE если элемент последовательности чисел от 1 до 50 
#больше равно 30 и FALSE в противном случае

#2. создать логический вектор Rr_y, элемент которого равен TRUE, 
#если элемент последовательности чисел от 1 до 50 больше 15 и меньше 25


######Про скобки#######
#Не надо ставить скобки ВЕЗДЕ, это загромождает код и мешает его прочтению. Скобок и так будет навалом

####Скобка в начале и в конце ЦЕЛОГО выражения БЕССМЫСЛЕННА 
Re<-(seq(from=1, to=20, by=30)>30) #НЕПРАВИЛЬНО Скобка ничего не добавляет, только мешает
Re<-seq(from=1, to=20, by=30) > 30 #ПРАВИЛЬНО


####Скобки НИКОГДА НЕ ставятся если
#1. производится только одна логическая операция (>,<,==, %in% )
A<-seq(5,100,2) %in% seq(10,100,3)
A<-!seq(5,100,2) %in% seq(10,100,3) #если только одна логическая операция после ! знака не нужно скобок
#(хотя если уж очень длинная операция, то можно) ставить скобку тоже

#2. производится две логические операции (>,<,==, %in%) соединенные & или | и нет !
C<-seq(4,100,2)
B<- C>50 | C %in% c(4,40,46)

#3. производится сколько угодно логических операций, соединенных ТОЛЬКО & ИЛИ ТОЛЬКО | и не включающие !
D<-C>50 & C<=70 & C %in% seq(6,80,3) #так как & ("и") предполагает одновременное выполнение всех условий и порядок не важен 
D1<-C>50 | C==70 | C %in% seq(6,80,3) #так как | ("или") предолагает выполнение хотя бы одного условия

####Скобки МОГУТ БЫТЬ необходимы тогда, когда важен порядок выполнения логических операций

#1.производится две и более логические операции (>,<,==, %in%) соединенные & или | НО есть !
K<-!C %in% seq(6,80,3) & C<=70 #в этом случае ! относится к C %in% seq(6,80,3)
K1<-!(C %in% seq(6,80,3) & C<=70) #скобки определяют к чему относится ! ("не")

#2. Производится более двух логических операций и в них присутсвует КАК & так и |
M<-C>50 & C<=70 | C %in% seq(6,80,3) #выполняются по порядку сначала 1) C>50 & C<=70, а потом 1) | C %in% seq(6,80,3)
M1<- C>50 & (C<=70 | C %in% seq(6,80,3)) # выполняется сначала 1) C<=70 | C %in% seq(6,80,3), а потом 1) & C>50



######## Subsetting vector - вычленение из вектора его части. Два варианта#####################

#####Первый вариант - указание ВЕКТОРА ПОРЯДКОВЫХ ЧИСЕЛ элемента вектора, которые нужно выбрать

A<-letters #letters - это зарезервированное название вектора (презагруженные данные) - все буквы ангийского алфавита
A
A[20] #возвращает 20 элемент вектора
A[20:26] #возвращает c 20 по 26 элемент вектора
A[seq(1,26, by=2)] #каждый второй элемент
A[c(2,4,5)] #обязательно в этом случае нужно с(), так как в квадратных скобках должен быть вектор
A[2,4,5] # так не работает

d <- c(3,6, 10:15)
A[d] #не забывайте в квадратных скобках тоже вектор


A[c(2,4,5)] [2] #выполняется последовательно - сначала вычленяет вектор из трех элементов а потом берет второй элемент нового вектора
class(A[c(2,4,5)]) #A[c(2,4,5)] - это ветор того же класса что и A, с ним можно производить дальнейшие операции
B<-A[c(2,4,5)]

A[length(A)] #последний элемент вектора A

B<-A[length(A):1] # задом наперед
C<-letters[seq(2,length(letters),by=2)] #каждая вторая буква алфавита


####Перезаписывание и добавление элементов вектора
A[20]<-"no"
A[c(2,4,5)]<-c("second","forth","fifth") #обратите внимание длинна векторов справа и слева должна быть одинаковой
A[c(2,4,5)]<-NA #либо то что слева, должно быть меньше чем то что справа, тогда то что справа повторится необходимое число раз

length(A)
A[27]<-"no letter" # если 27 элемента раньше не было то он создается
A[27:28]<- c("no letter 1", "no letter 2")
A <-  c(A[1:26],"no letter 1", "no letter 2") #делает тоже самое но более громоздко
A[50] <-"are you stupid, English alphabet isn't so long"
A #между 28 и 50 создались NA
A[length(A)+1]<-"you are ... " #добавление нового элемента, если не знаешь длинну вектора 

A[-c(2,3)] #знак минус означает выбор всех кроме них


#####минизадание4########
V<-c(9-seq(4,90,4),60,rep(88,15))

#1. выберите первые 10 элементов вектора V
#2. Выберите последние 10 элементов вектора V
#3. Выберите 1-ый, 25-ый и последний элемент вектора V
#4. добавьте к вектору V в конце 3 новых элемента, равных 27, 56 и 98

####Второй вариант используем логический вектор который по длинне РАВЕН исходному вектору
A<-letters
D<-c(rep(TRUE, length.out=10), rep(FALSE,10),rep(TRUE,6)) #rep() - повторяет нужное число раз
D #длинна 26 как и у вектора A

A[D] #первые 10 и последние 6 букв, там где у D стоит TRUE
A=="c" #тоже логический вектор, длинной равной A, поэтому можем использовать для subsetting
A==c #не забываем КОВЫЧКИ
A[A=="c"] #это несколько бесмысслено, но нужно будет когда перейдем к Data.frame 

B<-c("a","k", "о", "c","f","h","rt", "ы")
A[A %in% B] #почему не выбралось о?

A<-(1:500-50)/2
A[A<50&A!=7]
A[!A %in% c(50,130,170)/2]
C<-seq(1,500,20)/2
A[!A %in% C]
length(A)
length(A[!A %in% C])

#с помощью второго способа также можно перезаписывать элементы
A[A %in% C] <- 0 #обнуляем элементы совпадающие с С
A[A == 0] <- A[1] #а теперь присваиваем нулевым значениям, значения первого элемента

#################Домашнее задание###########################
#1.посчитать разность между двумя средними (постарайтесь в одну строчку): 
      #1)среднее от последовательности чисел от 1 до 10000 
      #2) среднее от последовательности чисел от 1 до 500 делящихся на 5


#2. создать логический вектор RE, элемент которого равен TRUE, если элемент последовательности чисел от 10 до 300, делящихся на
  #10 равен 20 ИЛИ 100 и FALSE в противном случае

#3. создать логический вектор Rt, элемент которого равен TRUE, если элемент последовательности ЧЕТНЫХ чисел от 1 до 500 
  #равен какому либо элементу последовательности от 1 до 500 делящихся на 55

#4.создать вектор AB.1 числовой последовательности от 30 (первое значение) до 500 в котором будут только четные числа
#5. переделать этот вектор чтобы значения шли по убыванию
#6. вывести на экран каждое третье значение этого вектора
#7. создать вектор AB.2 равный всем значениям первого вектора меньше 100 и больше 50
#8. у второго вектора вывести на экран 1-ый, 3-ий и 6-ой элементы 
#9. Присвоить всем элементам  вектора AB.2 которые делятся на 3 значаение NA


##########################День 3########################################################

rm(list=ls()) #удаление всех объектов из памяти (Global Environment)


#############Класс Data.frame#################
#Это совокупность векторов одной длинны - фактически это Таблица с данными
hryvna<-c(23.8421,23.9376, 23.7285,23.6641,23.7134)

#создание data.frame с нуля
currency.fx<-data.frame(eur=c(75.5481, 75.5541, 75.3861,	74.6312, 75.1932), 
                        usd=c(66.5499, 66.3318,66.0016,65.9170, 65.9300), 
                        hryvna=hryvna) 
currency<-data.frame() #создание пустой data.frame

currency.fx  

class(currency.fx)
View(currency.fx) #очень полезна если таблица большая
str(currency.fx) #структура объекта
summary(currency.fx)

nrow(currency.fx) #кол-во рядов
ncol(currency.fx) #кол-во колонок
length(currency.fx) #аналогично ncol, но лучше не пользоваться

names(currency.fx) #ВЕКТОР имен колонок (переменных), с ним можно делать все что можно делать с векторами
names(currency.fx)[3] <-"uah" #переименование колонки
names(currency.fx)

row.names(currency.fx) #имена рядов, реже используется
row.names(currency.fx)<-letters [1:5] #переименовываю имя ряда

#######минизадание########
#создайте data frame: Animals из трех рядов и 4 колонок: species, ID, age, Dead. 
#Последняя колонка должна быть logical. Значения придумайте сами



#####Операции с data.frame, только если все столбцы числовые 
#4*currency.fx
#currency.fx-currency.fx/4
#currency.fx*c(1:5) #каждый столбец умножается на этот вектор
#currency.fx*currency.fx 
#currency.fx^2
#max(currency.fx)


##########subseting data.frame#########
ir <- iris #iris презагруженный объект data.frame
View(ir)
str(ir) #обратите внимание на знак доллара

###1 способ - работает только с колонками (переменными) ####
ir$Sepal.Length #на выходе колонка в виде ВЕКТОРА
ir$"Sepal.Length" #это один из немногих случаев когда можно и в ковычках и без ковычек

#с ним можно делать всё что можно с вектором
class(ir$Species)
levels(ir$Species)
ir$Sepal.Length>5

#можно делать и subseting
ir$Sepal.Length[1:10]
ir$Sepal.Length[ir$Sepal.Length<5] <- NA
ir$Sepal.Length[Sepal.Length>5] #распространенная ошибка, забывают во второй раз писать ir$
Sepal.Length <- ir$Sepal.Length #а вот так мы можем создать новый вектор из колонки

ir$Sepal.Length[ir$Species=="setosa"] #все Sepal.Length (чашелистик) для вида setosa. не забываем ковычки
ir$Sepal.Length[ir$Sepal.Length>5 & ir$Sepal.Width<3 & ir$Species=="versicolor"]

ir$Species[ir$Species=="versicolor"] <- "vers" #нельзя, так как факторная переменная, заменяет на NA
ir$Species[is.na(ir$Species)] <- "versicolor" #is.na() - возвращает TRUE тем элементам вектора которые NA


levels(ir$Species)[4]<-"vers" #добавляем новую категорию в факторную переменную
ir$Species[ir$Species=="versicolor"] <-"vers" #теперь можем заменить


#самый удобный способ для создание новой колонки - это как раз через $
ir$Petal.Area<-ir$Petal.Length*ir$Petal.Width
ir$age<-"not known"


#####минизадание: создать вектор Petal_l (не в data.frame, а свободный)  
#равный вектору Petal.Length из  data.frame ir но только БЕЗ вида "virginica" 


#############2 способ -универсальный: два измерения [строки,столбцы]#######
## 2а - порядковые номера
#название колонок не являются первой строкой data.frame
ir[2,5] #вторая строка, 5-я колонка
ir[1:4,4:5] #1-4 строку, 4-5 колонка
ir[c(1,5), c(2,4)] #
ir[nrow(ir),ncol(ir)-1] #предпоследний элемент data.frame

#пустое место на месте строк/колонок означает выбор всех рядов или колонок 
ir[1,] #первый ряд и все колонки  (весь второй ряд)
ir[,c(1,5)] #первая и 5-я колонки, на выходе data.frame!!
ir[,3] #аналогично ir$Petal.Length, результат - вектор!!

#отрицательные числа означают исключение этих порядковых чисел 
ir[-1,-c(1,5)] #знак минус означает исключая эти порядковые номерa (в данном случае колонок). БЕЗ 1-ой и 5-ой колонки

#Создаем новый data.frame, как результат subsetting
ir_1 <- ir[,-c(1,5)]
class(ir_1) 

ir[-1,] #без первого ряда
ir$Sepal.Length[-c(1,10)] #с векторами тоже самое, просто забыл рассказать в ПРОШЛОМ занятии

ir_1<-ir[1:10,] #создаю новый data.frame из 10 первых рядов старого
str(ir_1)
ir[,ncol(ir)] <- 0 #обнуляю ВСЮ последнюю колонку
ir<-ir[,-ncol(ir)] #удаляю последнюю колонку, перезаписав data.frame

ir[nrow(ir)+1,] <- c(2,4,6,8,"setosa",12) #добавление новой строки в конец, !сделал всё character

ir[nrow(ir)+5,] <- c(0,0,6,0,"setosa",0) #добавление новой строки через 4 строки, между ставиться NA
#####минизадание######
#Вывести на экран 5 - 10 и 15 ряды из ir без 3-ей колонки

#####2_б Логический вектор########
#в качестве условия ЧАЩЕ всего логические операции с колонками ТОГО ЖЕ САМОГО data.frame
#условие почти ВСЕГДА используется для рядов
ir <- iris 
ir[ir$Petal.Length > 4.5,] #выбирает ряды где выполняется условие и все колонки
ir[Petal.Length >4.5,] #пропущено ir$

ir[, names(ir)!="Sepal.Width"] #Значительно РЕЖЕ условие пишется для колонок

#можно миксовать способ 2а и 2б
ir[ir$Petal.Width < 1,1:3] #1-3 колонка, для тех рядов где выполняется условие

ir[ir$Petal.Width < 1,3]<-round(ir[ir$Petal.Width < 1,3],0) #мы переписали данные, округлив их до первого знака

ir[ir$Petal.Width==max(ir$Petal.Width),5] #вид, для которого лепесток имеет наибольшую ширину, 3 случая одинаковой ширины
ir[ir$Petal.Width==max(ir$Petal.Width),5][1] #выбираем первый

#subseting можно делать несколько раз подряд
ir[ir$Petal.Width>mean(ir$Petal.Width),] [1:2,] 

###не забываем subsetting с [] можно ставить слева и таким образом переписывать
ir[ir$Petal.Width==min(ir$Petal.Width),1:3]<-0

######минизадание####################### 
#создать data.frame ir.hr в котором будут все данные ir кроме колонки "Species" и кроме тех рядов 
#где Petal.Width равен 0.2,  1.3 или 1.6


####2c ВЕКТОР названий колонок/рядов, в КОВЫЧКАХ!!
###
ir[,"Sepal.Width"] #аналогично ir$Sepal.Width
ir[,Sepal.Width] #не забывайте КАВЫЧКИ - а то R думает что это название объекта
a<-"Sepal.Width"
ir[,a] #а вот так можно
ir[,c("Sepal.Width","Species")] #результата Data.frame


ir[,-c("Sepal.Width","Species")] #минус не работает с названиями колонок, только с их порядковыми номерами
ir[,!names(ir) %in% c("Sepal.Width","Species")] #можно так, но это способ 2б 

#c рядами ситуация аналогична, только названия ставятся в другое место 
row.names(ir)
row.names(ir)<-paste(row.names(ir), letters, sep="_") #paste() сшивает character вектора
ir[c("2_b","9_i"),]

#способ 2с можно миксовать с 2a и 2b
ir[ir$Petal.Length <= 3,c("Sepal.Width","Species")]
ir[1:4,c("Sepal.Width","Species")]

######минизадание####
# вывести на экран данные ir для колонок "Petal.Length","Petal.Area" 
#для видов versicolla 

#################Дошашнее задание 2###########################
data_chick<-ChickWeight #ChickWeight - это одна из предустановленных (built-in) data.frame: вес,возраст,номер цыпленка, номер диеты
str(data_chick)
class(data_chick$Chick)#обратите внимание "ordered"

#1. выберите  данные по цыплятам 13-18 и запишите в датафрейм chick_13_18. 
#Далее в заданиях используйте этот дата фрейм chick_13_18

#2. выведите на экран первые и последние 5 строчек датафрейма без колонки Diet

#3. выведите на экран data.frame ТОЛЬКО c колонками с возрастом и номером цыпленка  и только 
#для случаев веса меньше 100

#4. выведите на экран все данные цыплят для возраста 12

#5. создайте новую переменную в датафрейм: AvSpeed - средняя скорость набора веса (вес/возраст)

#6. как видно скорость для возраста 0 получилась бесконечной, замените для этого возраста 
#значение скорости на NA (вместо inf)

#7. добавьте в датафрейм новую СТРОЧКУ в которой будет средний вес цыпленка 13 за все время, в качестве значения возраста (Time) 
#напишите "average", #обратите внимание что вы таким образом изменили класс вектора Time


#######День 4########################

#####3 вариант - специальные функции для subseting########
ir <- iris

head(ir, n=3) #первые 3 ряда - аналогично ir[1:3,]
tail(ir, n=2) # последние 2 ряда - аналогично ir[(nrow(ir)-1):nrow(ir),]
head(ir$Sepal.Length, n=3) #для векторов тоже работает

#subsetting по рядам с логическим сравнением
subset(ir, (Sepal.Width <3 & Species=="setosa")| Species=="virginica") #здесь название колонок БЕЗ КАВЫЧЕК (исключение из правила)

#subset полезен если у тебя множественное сравнение, экономит место, так как не надо каждый раз писать название
# data.frame - сравните аналог 
ir[(ir$Sepal.Width <3 & ir$Species=="setosa")| ir$Species=="virginica",]

subset(ir,Sepal.Width <3, select=c(1,5)) #параметр select выбирает колонки
ir5 <- subset(ir,Sepal.Width <3, select=c("Species","Sepal.Width","Sepal.Length")) #можно и так, порядок колонок поменялся
ir[ir$Sepal.Width <3,c("Species","Sepal.Width","Sepal.Length")]

####нельзя subset, head, tail слева от знака присваивания (поэтому слева только [])
#то есть нельзя перезаписывать
subset(ir, ir$Sepal.Width<6) <- 0 #ошибка

#последовательный subsetting
subset(ir, ir$Sepal.Width<6)$Species [1:3] 

#вид у которого разница длинной и шириной лепестка была максимальной, СКОБКИ ЗДЕСЬ ВАЖНЫ!
subset(ir, (Petal.Length-Petal.Width)==max(Petal.Length-Petal.Width))$Species 

# а его аналог без subset 
ir$Species[(ir$Petal.Length-ir$Petal.Width)==max(ir$Petal.Length-ir$Petal.Width)] #очень много ir$

########Cливание двух датафреймов
###по строкам (количество колонок должно быть равно и названия колонок)

ir1 <- ir [1:10,]
ir2 <- ir [50:70,]

ir3<-rbind(ir1, ir2) #raw bind - слияние по рядам

ir[nrow(ir)+1,]<-ir[1,] #добавить 1 ряд
ir <- rbind(ir, ir[1,])

###сливание по колонкам, по колонкам (количество строк долно быть равно)

#sample - берет случайным (равновероятным) способом элементы из x 
ir_add <- data.frame(ILL=sample(x= c(TRUE,FALSE), size = nrow(ir), replace = TRUE), 
                     time=sample(x= seq(0,24, by=0.01), size = nrow(ir), replace = TRUE))

ir<-cbind(ir,ir_add) #column bind



####минизадание:######### 
#с помощью subset выведете на экран данные (ряд или если несколько, то ряды) 
#из ir когда Petal.Length был минимальным
#Создайте новый дата фрейм из этого ряда (рядов) и последних десяти рядов ir



######### Задачи с subseting (самостоятельно изучить)
######статистическая операция с результатом subsetting
#разность средних значений ширины лепестка у двух видов
mean(ir$Petal.Width[ir$Species=="vers"]) - mean(ir$Petal.Width[ir$Species=="setosa"])

#максимально значение ширины лепестка у одного из видов для случаев когда длина лепестка меньше среднего
max(subset(ir,Species=="setosa" & Petal.Length < mean(Petal.Length))$Petal.Width)

######узнать делители числа
a<-345667
del<-data.frame(del=1:a, result=a/(1:a))
del[(del$result-round(del$result))==0,]$del #функция round округляет до указанного порядка (по умолчанию до целого)
del[(del$result-round(del$result))==0,1]




######Класс объекта list##########
######класс list - список разномастных объектов
###сделаем list с исследованием
data_chick<-ChickWeight #презагруженный data.frame
chick_survey<-list(data=data_chick, authors=c("Anton", "Gosha", "Petya"), 
                   temperature=data.frame(year=c(2016:2018),temp=c(23,25,27)),
                   period="2016-2018", journal="Ecology", Citations=134) 

#первый и третий элемент - data.frame, остальные вектора
str(chick_survey)#показывает разноуровневую картину и как добраться до нужного элемент разного уровня

###subseting
#1 c помощью $ и названия элемента
chick_survey$authors
chick_survey$data$Time #сначала subsetting list а потом data.frame

##2 c помощью двойных квадратных скобок [[]] и ОДНОГО названия либо ОДНОГО порядкового элемента
#по названию
chick_survey[["authors"]]
chick_survey[[authors]] #забыли кавычки

#по порядковому номеру
chick_survey[[3]] # аналог, в двойный скобках только одно измерение - никаких запятых в [[]]

chick_survey[[c("authors","data")]] #когда несколько названий то не работает


#3 если одинарные скобки то выдает не элементы, а list из этих элементов
chick_survey[2] # list из одного элемента
class(chick_survey[2])
class(chick_survey[[2]])


chick_survey[c(1,3)] #list из двух элементов
chick_survey[c("data","temperature")] #то же самое
chick_survey<-chick_survey[-length(chick_survey)] #без последнего элемента

#последовательный subsetting
chick_survey[[1]] [1,3] #так как chick_survey[[1]] обычная data.frame
a<-mean(chick_survey[[1]]$Time)

##часто list сложные объекты, типа результат регрессии
lm(data_chick$weight ~ data_chick$Time) #lm() - функция линейной регрессии, ~ знак зависимости
a<-lm(data_chick$weight~data_chick$Time)
?lm

str(a) #list из 12 элементов, один из них data.frame -model
str(a$model) #это исходные данные модели
a$fitted.values # 
a$coefficients

#a$qr - лист 
str(a$qr$qr)
dimnames(a$qr$qr)[[2]] #dimnames - тоже лист


####Минизадание####
#выведите на экран ошибки (residuals) регрессии a
#создайте новый лист в котором будут 2 элемента 1)эти ошибки и 2) автор модели (то есть Anton Pletenev) 

###########графики#############################
ir<-iris

##график одной переменной
plot(ir$Sepal.Length) #по порядку все

##scatter plot
plot(y=ir$Sepal.Length, x=ir$Sepal.Width)

##график из data.frame
plot(ir) #plot - generic функция
#plot(a)
#вид графика
?plot
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, type="l")
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, type="o")
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, type="b")

#название графика и осей
#параметр main - название графика; sub - дополнительное название; xlab,ylab название осей
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, type="o",
     main="Характеристики чашелистика", sub="Sepal.Length vs Sepal.Width",
     xlab="Ширина, см", ylab="Длинна, см")

#цвет
#параметр col
?par
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, type="o", col="blue",
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, type="o", col=14,
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")

#http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf очень много цветов
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, type="o", col="darkgoldenrod", # в ковычках
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")

#####вид точек и линий
#https://www.statmethods.net/advgraphs/parameters.html   хороший guide

#pch - вид точек, lty - вид линий, lwd - толщина линии
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, type="o", pch=16, lty=2, lwd=2,
     col="darkgoldenrod", # в ковычках
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")

####величина символов
#cex - увеличивает все символы (точки) на графике (по умолчанию cex=1)
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, cex=2,
     type="o", pch=16, lty=2, lwd=2,
     col="darkgoldenrod", # в ковычках
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")

#cex.lab - величину шрифта названия осей, cex.axis - величину шрифта чисел на осях
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, cex=1.5, cex.lab=1.5,cex.axis=1.5,
     type="o", pch=16, lty=2, lwd=2,
     col="darkgoldenrod", # в ковычках
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")

#добавить еще линию
#функция points
points(y=ir$Petal.Length, x=ir$Petal.Width, cex=1.5,
       type="o", pch=17, lwd=2,
       col="darkblue") #не хватает длинны оси в plot

#перестраиваем первый график добавляя параметры xlim и ylim в которых вектор из 2 чисел (начальное, конечное значение)
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, xlim=c(0, max(ir$Sepal.Width,ir$Petal.Width)),
     ylim=c(0, max(ir$Sepal.Length,ir$Petal.Length)),
     cex=1.5, cex.lab=1.5,cex.axis=1.5,
     type="o", pch=16, lty=2, lwd=2,
     col="darkgoldenrod", # в ковычках
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")

points(y=ir$Petal.Length, x=ir$Petal.Width, cex=1.5, cex.lab=1.5,cex.axis=1.5,
       type="o", pch=17, lwd=2,
       col="darkblue")#теперь все ОК


##добавить вертикальные и горизонтальные линии
abline(h = mean(ir$Sepal.Length)) #
abline(v = mean(ir$Sepal.Width))
abline(v = mean(ir$Petal.Width), h = mean(ir$Petal.Length), col = "brown", lwd =2)
#а вообще то надо вот так
abline(v = c(mean(ir$Petal.Width), mean(ir$Sepal.Width)),
       h = c(mean(ir$Petal.Length), mean(ir$Sepal.Length)), col = "pink", lwd =2)


########в качества pch, col и многих других параметров может выступать вектор равный y и x
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, col=1:nrow(ir),
     cex=1.5, type="p", pch=1:25, lty=2, lwd=2,
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")


##теперь засунем в col и pch переменную название вида
as.numeric(ir$Species)
plot(y=ir$Sepal.Length, x=ir$Sepal.Width, col=as.numeric(ir$Species),
     cex=2, type="p", pch=as.numeric(ir$Species), lty=2, lwd=2,
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")

#создаю свои цвета для каждого вида
color<-rep("darkblue", nrow(ir))
color[ir$Species=="setosa"] <- "darkgoldenrod"
color[ir$Species=="versicolor"] <- "deeppink"

plot(y=ir$Sepal.Length, x=ir$Sepal.Width, col=color,
     cex=2, type="p", pch=as.numeric(ir$Species)+15, lty=2, lwd=2, #у нас будет pch 16,17,18
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")

#как сохранять картинку

png(filename="C:\\R\\Teaching\\plot1.png")

plot(y=ir$Sepal.Length, x=ir$Sepal.Width, col=color,
     cex=2, type="p", pch=as.numeric(ir$Species)+15, lty=2, lwd=2, #у нас будет pch 16,17,18
     main="Характеристики чашелистика",
     xlab="Ширина, см", ylab="Длинна, см")
dev.off()

#гистограмма
hist(ir$Sepal.Length)
#используются те же параметры par
hist(ir$Sepal.Length, col="blue",
     main="Характеристики чашелистика",
     xlab="Длинна, см", ylab="Кол-во экземпляров")
#важный параметр breaks
hist(ir$Sepal.Length, breaks=50,
     col="blue", main="Характеристики чашелистика",
     xlab="Длинна, см", ylab="Кол-во экземпляров")

hist(ir$Sepal.Length, breaks=c(4,5,6,7,8),
     col="blue", main="Характеристики чашелистика",
     xlab="Длинна, см", ylab="Кол-во экземпляров")

#boxplot 
boxplot(ir$Sepal.Length ~ ir$Species)


#################Домашнее задание 3###########################
data_chick<-ChickWeight #работаем снова с ней


#1.нарисовать зависимость веса от времени (scatterplot)

#2. точки каждого цыпленка сделать отдельным символом 

#3 нарисовать нарисовать зависимость веса от времени (scatterplot), 
#где будут только те цыплята которые когда-либо достигли веса (или превысили) 300

#4.#добавить туда линию отмечающую максимальный вес цыплят (только тех что на графики)  в возрасте 12

#5. построить гистограмму распределения веса (всех цыплят) в возрасте 21

#6. построить boxplot веса цыплят от диеты




#################День5#####################
####Запись!
#

######пакеты#######################

#install.packages("openxlsx") #в кавычках! - нужно запустить "один раз в жизни", загружает пакет из интернета
library("openxlsx") #нужно запускать для каждой новой сессии Rstudio, загружает пакет в оперативную память

#https://cran.r-project.org/web/packages/openxlsx/index.html
#Reference manual - все функции пакета
#Vignettes - более дружелюбное объяснение применения функций с примерами

############Загрузка и выгрузка данных#####################
getwd() #текущая папка по умолчанию
setwd("C:/R/Teaching/Git/Data") #set working directory - установка папки по умолчанию
#Обратите внимание, что здесь не прямой (как в Windows), а обратный слеш, так как прямой используется для других целей

#другой способ - использовать двойной прямой слеш
setwd("C:\\R\\Teaching\\Git\\Data")

#при загрузке или выгрузки данных, если путь к файлу не указан, то используется путь к папке по умолчанию 

#####загрузка xlsx

films<-read.xlsx(xlsxFile = "film.xlsx") #загружает как data.frame

#
films<-read.xlsx(xlsxFile="C:/R/Teaching/Git/Data/film.xlsx") #можно и весь путь прописать, если не в папке по умолчанию

str(films) #все строковые воспринимает как character

titanic<-read.xlsx(xlsxFile="C:/R/Teaching/Git/Data/film.xlsx", sheet=2) #загружаем со второго листа

str(titanic)

#создает новый data.frame только из комедий с наградами
comedies<-films[films$Subject=="Comedy"&films$Awards=="Yes", ]

#теперь выгружаем (сохраняем) новую data.frame на диск
write.xlsx(comedies, file="Comedies with awards.xlsx") #! нет знака присваивания



#######csv####################
###загрузка csv, функция read.csv2 используется для загрузки csv "российского формата" (где разделители между колонками точки с запятой)
films<-read.csv2(file="film.csv", dec=".") #загружает как data.frame
#параметр dec - какой знак отделяет целые от десятичных, если у вас запятая, то надо использовать ","  

films<-read.csv2(file="C:/R/Teaching/Data/film.csv", dec=".") #можно и весь путь прописать, если не в папке по умолчанию

str(films) #все строковые воспринимает как факторные

films<-read.csv2(file="film.csv", dec=".", stringsAsFactors = FALSE) #
# stringsAsFactors - воспринимать ли строковые переменные как факторы

str(films)

#другой вариант, прописать все классы переменных вручную с помощью параметра colClasses
films<-read.csv2(file="film.csv", dec=".", 
                 colClasses = c("integer", "integer", "character", "factor",rep("character",3),"integer","factor"))

str(films)

#создает новый data.frame только из комедий с наградами
comedies<-films[films$Subject=="Comedy"&films$Awards=="Yes", ]

#теперь выгружаем (сохраняем) новую data.frame на диск
write.csv2(comedies, file="Comedies with awards.csv")

##############Задание в классе######################
#загрузить свои данные в R, 
#сделать какой-то subseting - сохранить его в xlsx

#####################Полезные функции################
data_chick<-ChickWeight
### unique - оставляет только уникальные значения
unique(data_chick$Chick)

### table - подсчитывает количество повторений различающихся значений 
table(c("M","T","K","M"))
table(data_chick$Chick)
table(data_chick [,c("Chick","Diet")]) #двойное сочетание
tab<-table(data_chick [,c("Chick","Time")])
str(tab) #класс table, subsetting как  [] data.frame
tab[1,2]
tab[1,]
tab_data<- as.data.frame(tab)
#### paste - объедининяет множество значений в одну строковую переменную
name<-"Anna"
age<-17
paste(name,"is", age,"years old", sep=" ") #sep - разделитель, в нашем случае пробел
data_chick$ID<-paste(data_chick$Chick,data_chick$Time,sep="_")


###with() - позволяет не писать название data.frame
with(data_chick, paste("Maximum weight was", max(weight), "brought by chicken", Chick[weight==max(weight)],
                       "with Diet", Diet[weight==max(weight)], sep=" ")) #sep - разделитель, в нашем случае пробел

with(data_chick, weight[1:2]) #аналог data_chick$weight[1:2]
#####минизадание: напишите фразу "Minimum weight was reached at Time ... by chicken ..." 


###### arrange (функция пакета plyr) сортировка data.frame по одному или нескольким столбцам
#install.packages("plyr") #- так устанавливают пакеты - это нужно делать только один раз
library("plyr") 

data_chick<-arrange(data_chick, Chick) #!кавычки у Chick  не нужно писать, заметьте, что Chick - ordered factor и сортируется по  levels
levels(data_chick$Chick) #обратите внимание сортирует согласно уровням факторной переменной
data_chick<-arrange(data_chick, Chick, decreasing = TRUE) #параметр decreasing=TRUE если хочешь по убыванию
data_chick<-arrange(data_chick, Diet, Chick,Time) #сначала по Diet, потом по Chick (внутри каждой Diet)

###range - расброс - min-max
range(data_chick$weight) #вектор из 2 значений

###diff - разность соседних элементов вектора
data_chick_12<-data_chick[data_chick$Chick==12,]
diff(data_chick_12$weight) #фактически это прирост
data_chick_12$diff_weight<-c(NA,diff(data_chick_12$weight)) #NA нужен так как количество прироста на 1 меньше чем кол-во наблюдений
data_chick_12

#####cumsum - кумулятивная сумма
cumsum(1:100) 
cumsum(c(0,data_chick_12$diff_weight[-1]))+data_chick_12$weight[1] #мы востановили вес зная приросты и начальное значение
data_chick_12$weight

##### which.min и which.max - возвращает порядковый номер максимального или минимального элемента
which.min(data_chick$weight)
data_chick$Chick[which.min(data_chick$weight)] #какой цыпленок с минимальным весом
data_chick$Chick[data_chick$weight==min(data_chick$weight)] # это аналог без использования функции - занимает больше места
data_chick_12$Time[which.max(data_chick_12$diff_weight)] #в каком возрасте набрал максимальный вес
which.min(data_chick$weight-(data_chick$weight)^2)
######минизадание: 
######в каком возрасте (кроме нуля) у цыпленка 12 была максимальная средняя скорость роста (weight/Time)


#######%>%
#install.packages("magrittr")
library("magrittr")
#%>% передает в функцию слева от себя в качестве первого параметра результат функции справа от себя

head_15 <- head(subset(data_chick, Chick %in% c(16,20,21)),15)

head_15 <- data_chick %>% 
                subset(Chick %in% c(16,20,21)) %>%
                head(15)

mean_weight <- mean(subset (data_chick, Chick %in% c(16,20,21))$weight)

### при subsetting точка означает объект слева от %>%
mean_weight <- subset (data_chick, Chick %in% c(16,20,21)) %>%
                      .$weight %>%
                        mean()

sum<- subset (data_chick, Chick %in% c(16,20,21)) %>%
          .[1:15,2] %>%
          sum()

sq_mean_weight <- round(sqrt(mean(subset (data_chick, Chick %in% c(16,20,21))$weight[1:15])), 2) #sqrt() возвращает квадратный корень

sq_mean_weight <- data_chick %>%
                        subset (Chick %in% c(16,20,21)) %>%
                        .$weight %>%
                        .[1:15] %>%
                        mean() %>%
                        sqrt() %>%
                        round(digits=2) 

######join - умное объединение двух data.frame
#install.packages("dplyr")
library("dplyr")

info <- data.frame(Chick = factor(c(18,15), levels = levels(data_chick$Chick), ordered = TRUE), 
                   DEAD = TRUE, age_of_death = c(20,35))

#мы хотим добавить эту информацию в наш data.frame

data_chick <- left_join (data_chick, info)

info2 <- data.frame(Chick = factor(15, levels = levels(data_chick$Chick), ordered = TRUE), 
                    Time = c(0, 4, 16, 30, 45),
                   height = c(1,3,5,6,9), color = c(rep("yellow",3), rep("red",2)))

unique(data_chick$Time)

data_chick <- left_join (data_chick, info2)


####минизадание 
#добавьте информацию в data_chick что все циплята которые получали диету 4 в возрасте 2 были глухими



#################Задание в классе 3###########################
data_plant<-CO2 #данные - концентрация CO2 (conc) и сколько потребило растение
?CO2

#1. создать list с именем Plants_chilled из двух элементов: (1) - data.frame с именем chilled, в котором будут только данные по chilled  
#растениям, (2) вектор Plants с названиями (Plant) из первого (1) элемента, в нём каждое имя растения должно встречаться 1 раз

#2 добавить в list из первого задания элемент с одним значением character :"Mean concentration of CO2 is ..., Mean uptake is...",
#  где в качестве ... надо вставить расчитанные значения 

#3. сделать data.frame c summary последних двух колонок data_plant (то есть data.frame из 2 строчек) на основе функции summary

#4. вывести таблицу с количеством случаев chilled и nonchilled в data_plant.

#5. Найти имя растения (Plant) у которого был минимальный uptake в nonchilled состоянии (с помощью which.min)

#6. У вас есть информация что в названии растения две первые буквы означает виды: Qn - Quince Shrubs, Qc - Quaking Aspen Trees,
#Mn - Moonbeam Coreopsis, Mc - Miss Kim Lilac. Добавьте новую колонку с названием вида в data_plant, используя функцию match  


#################Домашнее задание 3###########################
trees<-Loblolly #высота деревьев разного возраста
#1. Номер семечка (seed) у которого был минимальный рост в возрасте 25

#2. минимальный возраст ПОСЛЕ которого рост растения превысил 27 
#(то есть в этом возрасте еще не превысил, а в следующем уже превысил)

##дополнительная информация: буквы, кодирующие семечки 
#(предположим это первая буква названия штата из которого семечка)
trees_2<-data.frame (Seed=unique(trees$Seed)[4:10], weight= c(LETTERS [4:9],20))

#3. Порядковый номер в алфавите буквенного кода семечки, которое набрало наибольший вес в возрасте 5 
#(те семечки у которых нет буквенного кода не учитывать)


beaver<-beaver1 #динамика температуры бобра

#4. время (time) максимального изменения температуры бобра 
#(время, когда это максимальное изменение закончилось)

#5. время (time) когда у бобра достигнута четвертая по величине температура тела


