#####Синтаксис#####

####присваивание значения объекту (если объекта раньше не было он создается)
age.robert<-23

#В названии объекта нельзя употреблять символы +,-, %,#,) ^ и т.д. так как они зарезервированы для другого

A<-2+3 # складываем и создаем А
A<-A^2
A <- 3.14

#вместо <- можно употребить =, но нерекомендуется так как используется и для параметра функции
A=A*10

#Для вывода на экран значения объекта нужно просто написать его имя
A

2+2*(8^6 - 2)/10 #это значение нигде запоминается так как никуда оно не присвоилось

####функция

A<-log(x=100, base=10) 
A

#название параметров функции можно не писать, сохранив их порядок
log(1024,2)

#или писать параметры в произвольном порядке, но писать их названия
log(base=2, 1024) #так как у функции только два параметра, то писать можно название только одного, а второй R поймет автоматически

#синтаксис некоторых  функции упрощен, например функция справка ?
?log  #справка функции, в функции чаще всего наиболее важные параметры идут вначале - часто у них нет значения по умолчанию

#если не указываешь значение параметра по умолчанию
log(5)

?seq #задает последовательность чисел
seq(from=1, to=50, by=10)
seq()
seq(to=50, 1, 10) #здесь мы прописали название только одного параметра, остальные R интерпретировал как они указаны по порядку

# если не указываешь значение параметра не по умолчанию
log()

#другие упрощенные функции
seq(from=1, to=50, by=1) #то же самое можно записать проще
1:50

#ВАЖНО: В качестве значения параметра функции может выступать другая функция или объект
A<-log(1024,4/2)
length(A)
A<-seq(from=log(exp(3)), to=A, by=log(A,10))
length(A)

A<-seq(from=log(exp(3)), to=A, by=log(A,10)) #неправильный формат значения параметра
length(A)

#СЛедующую строку запускать только ОБВЕДЯ ЕЁ
seq(from=log(exp(3)), to=A, by=log(A,10) # здесь забыта скобка, поэтому на консоле +, 
#то есть ожидание продолжения. Два варианта выхода - либо дописать необходимую скобку (в КОНСОЛЕ),
#либо нажать esc (тоже находясь в консоле)

##########Вектор - самый базовый (низший) класс R###########
######Классы векторов
A<-c(1,3,4,6, log(10,10)) #c() - это generic function создает вектор различных классов
A<-numeric(1,3,4,6, log(10,10))
A
class(A) #возвращает класс объекта
A<-as.numeric(c(1,3,4,6, log(10,10))) #принудительно делает numeric

A<-as.integer(A)
class(A)

length(A) #длина вектора
class(length(A)) #длина вектора очевидно всегда целое число

B<-numeric(length=10) #создает пустой numeric длинной 10
B
#Character - строковые переменные, не забываем кавычки
class(class(A))
A<-c("mama","papa","I want to eat 2 times", 2, class(A)) #c() - это generic function
A
class(A)

A<-c(mama,papa,"I want to eat 2 times", 2, class(A)) ##НЕ ЗАБЫВАЙТЕ КАВЫЧКИ

as.numeric(A) #не знает как превратить маму в число

A<-as.character(c(1,3,4,6, log(10,10))) #принудительно делает character
A #появились кавычки
as.numeric(A) #а вот превратить "1" в число смог

#Factor - обратите внимание, функцию можно написать в сколько угодно строк
C<-factor(x=c("first", "third", "forth", "second", "second","first"), 
          levels=c("first", "second", "third", "forth"), ordered =  TRUE) #параметр ordered позволяет указать что "first"> "second">"third"> "forth" 
C
class(C)
levels(C)
as.numeric(C) #значение становится соответсвующим порядковым номером уровня
as.numeric(levels(C)) # levels(C) - это character

#Logical
D<-c(TRUE, FALSE,FALSE, TRUE) #БЕЗ КАВЫЧЕК TRUE и FALSE это особые слова
D-1 #в алгебраических операциях TRUE=1, FALSE=0
sum(D)

D<-as.logical(c(1,0,0, 0,1)) # и наоборот в логических операциях 1 это TRUE, 0 - FALSE
D

D<-as.logical(c(2,0,0, 4,-1)) # всё что не ноль - TRUE

#####Операции с векторами
#Принцип: проводим операцию: каждый элемент первого вектора с таким же по порядку элементом второго вектора
#в идеальном случаи длинны векторов должны быть одинаковыми
A<-1:20
B<-seq(21,80,3)
length(A)
length(B)
B-A #+,-,*,/ как будто в Excel складываешь и вычитаешь колонки
B*A
B/A
C<-c(1,3)
A-C #если векторы не равны, то меньший вектор порторяется необходимое количество раз
A-rep(x=C,times=length(A)/2) #rep - повторяет x в течении times раз
A-1
3*A

mean(A) #среднее
sd(A) #среднеквадратичное отклонение
median(A) 
summary(A)
max(A)
min(A)
######Логические операторы
A<-seq(3,60,by=3)
A < 20 #фактически логический оператор - это упрощенная функция
A < sum(1:10)

A<=20 # меньше равно
A>=20 # больше равно
A==20 #так как = занято, то логическим оператором равно является == (два равно подряд), найди TRUE
B=20 #это просто присвоит вектору значения

D<-A==15

A!=20 #!= это неравно

!TRUE # ! меняет TRUE на FALSE и наоборот
!c(TRUE,FALSE,TRUE)

B<-c("mama","papa")
B=="mama" # 
B=="mama"
B>50 #больше\меньше считает сумму порядковых значений букв 

C<-factor(x=c("first", "third", "forth", "second", "second","first"), 
          levels=c("first", "second", "third", "forth"), ordered =  TRUE)
C<2 #для factor можно только операторы равно и не равно
C=="second"
C<"third" #так как у нас ordered factor мы можем сделать тако сравнение

A==c(10,11) #одновременное сравнение с двумя числами не проходит
A %in% c(10,11) # для одновременного сравнения 
!A %in% c(10,11) #все элементы A не равные 10 и 11

A<20&A!=10 #& - оператор "и", чтобы результат был TRUE должно быть TRUE и слева и справа от &, иначе FALSE

A<20|A==30  #| - оператор "или", чтобы результат был TRUE должно быть TRUE или слева или справа от |

A==c(10,11) #одновременное сравнение с двумя числами не проходит
A %in% c(10,11,25) # для одновременного сравнения оператор %in%
A ==10 | A ==11 | A==25 # можно написать и так, но это сложнее - больше букв

B<-seq(3,60,by=6)
match(B,A, nomatch=0) #возвращает порядковые номера 'элементов вектора A, которые совпадают с вектором B. НЕ перепутай первым идет вектор с которым сравнивают, вторым чьи порядковые номера возвращают


(A<40|A==21)&(A>10|A==3)&!(A %in% seq(0,60,by=6)) #сначало выполняется то что в скобках




######## Subsetting vector - вычленение из вектора его части. Два варианта

#####Первый вариант - указание порядковых элементов вектора которые нужно выбрать
A<-letters #letters - это зарезервированное название вектора - все буквы ангийского алфавита
A
A[20] #возвращает 20 элемент вектора
A[20:26] #возвращает c 20 по 26 элемент вектора
A[c(2,4,5)] #обязательно нужно с()
A[2,4,5] # так не работает
A[c(2,4,5)] [2] #выполняется последовательно - сначала вычленяет вектор из трех элементов а потом берет второй элемент нового вектора
A[length(A)] #последний элемент вектора A

B<-A[26:1] # задом наперед
С<-letters[seq(2,length(letters),by=2)] #каждая вторая буква

A[match(С,B,nomatch = 0)] #вытаскивает элементы A, которые по порядковым номерам совпадают с порядковыми номерами элементов вектора B имеющихся в векторе C 

####Второй вариант используем логический вектор который по длинне равен исходному вектору
D<-c(rep(TRUE, length.out=10), rep(FALSE,length.out=10),rep(TRUE,length.out=6)) #rep - повторяет нужное число раз
D #длинна 26 как и у вектора A

A[D]
A=="c"
A[A=="c"] 
A[A<"c"]
A[A<"k"&A!="a"]
A[A %in% c("a","k","m")]

B<-c("a","k","f","h")
A[A %in% B[B!= "k"]]


#################Задание в классе 1###########################
#создать вектор от 30 (первое значение) до 500 в котором будут только четные числа

#переделать этот вектор чтобы значения шли по убыванию

#вывести на экран каждое третье значение этого вектора

#создать второй вектор равный всем значениям второго вектора меньше 100 и больше 50

#вывести на экран 1, 3 и 6 по порядку значение второго вектора

#переделать второй вектор в логический (logical) вектор в котором  
#всем его значениям делящимся на 10 присваивается TRUE, а остальным FALSE

###################Домашнее задание 1###############################
#1. найдите сумму всех четных натуральных чисел меньше 10001

#2. посчитайте количество натуральных чисел меньше 10001, которые делятся на 3 и при этом не делятся на 2

##3. Сумма  натуральных чисел от  от 1 до 100000, котоые делятся на 13 и 17, но не делятся на 2
#для решения достаточно изученных знаний и функций, но можно также использовать функцию round 

#4. посчитайте количество четных чисел меньше 10001, когда сумма этого числа 
#с предшествующим ему нечетным числом делится на 3


#############Класс Data.frame#################
#Это совокупность векторов одной длинны - фактически это Таблица с данными
hryvna<-c(23.8421,23.9376, 23.7285,23.6641,23.7134)
currency.fx<-data.frame(eur=c(75.5481, 75.5541, 75.3861,	74.6312, 75.1932), 
                        usd=c(66.5499, 66.3318,66.0016,65.9170, 65.9300), 
                        hryvna=hryvna)
currency.fx  
class(currency.fx)
View(currency.fx) #очень полезна если таблица большая
str(currency.fx )
summary(currency.fx)
nrow(currency.fx) #кол-во рядов
ncol(currency.fx) #кол-во колонок
names(currency.fx) #имена колонок (переменных) - это ВЕКТОР, с ним можно делать все что можно делать с векторами
names(currency.fx)[3] <-"uah" #переименование колонки
names(currency.fx)
row.names(currency.fx) #имена рядов, редко используется
row.names(currency.fx)<-letters [1:5]


#####Операции с data.frame, только если все столбцы числовые 
4*currency.fx
currency.fx-currency.fx/4
currency.fx*c(1:5) #каждый столбец умножается на этот вектор
currency.fx*currency.fx 
max(currency.fx)

##########subseting data.frame
###1 способ - работает только с колонками (переменными) 
currency.fx$date<-c("m","t","w","th","fr","sa") #длинна вектора больше чем у data.frame
currency.fx$date<-c("m","t","w","th","fr")
4*currency.fx #уже нельзя так как один столбец это character
currency.fx$eu<-currency.fx$eur/currency.fx$usd
currency.fx$eur [1:3] #так как это обычный вектор, то его можно тоже subset - см. разделы про вектора 
currency.fx$eur[currency.fx$eur<75.5]
currency.fx$eur[eur<75.5] #ошибка, так как объекта eur нет, а есть объект  currency.fx$eur
currency.fx$eur[currency.fx$usd>66] #выводятся те курсы евро, когда доллар был выше 66 рублей 
currency.fx$eur[currency.fx$usd>66&currency.fx$uah<23.8]
currency.fx$eur[currency.fx$date=="m"]<-77.4 #мы переписали данные у этого вектора для понедельника

###2 способ -универсальный
## 2а - порядковые номера или TRUE/FALSE
currency.fx[2,5] #вторая строка, 5-я колонка
currency.fx[2:4,5:6]
currency.fx[c(1,5), c(2,4)]
currency.fx[nrow(currency.fx),ncol(currency.fx)-1] #предпоследний элемент data.frame

#пропущенное i или j означает все ряды или колонки 
currency.fx[2,] #второй ряд и все колонки  (весь второй ряд)
currency.fx[,c(1,5)] #первая и 5-я колонки
currency.fx[,3] #аналогично currency.fx$uah

currency.fx[,-c(1,5)] #знак минус означает исключая эти порядковые номерa (в данном случае колонок)
currency.fx[-1,] #без первого ряда

#условия
currency.fx[currency.fx$usd>66,] #условие почти всегда используется для рядов
currency.fx[usd>66,] #опять же объекта usd нет а есть currency.fx$usd
currency.fx[currency.fx$usd>66|currency.fx$date=="m", names(currency.fx)!="usd"] #полезное условие для колонок придумать сложнее, но можно
currency.fx[currency.fx$date=="t",1:3]<-round(currency.fx[currency.fx$date=="t",1:3],1) #мы переписали данные, округлив их до первого знака
currency.fx[currency.fx$usd==max(currency.fx$usd),"date"] #дата, когда курс доллара был максимален



#subseting можно делать несколько раз подряд
currency.NA<-currency.fx[currency.fx$usd>66,] [1:3,] [,1:2] 
currency.NA
#NA -missing values он выдал, так как после первого условия у нас оставалось 2 строчки, а я во втором subsetting выбрал три
is.na(currency.NA) #проверка на NA
currency.NA[!is.na(currency.NA$eur)&!is.na(currency.NA$usd),] #удаление строчки в которой есть NA

currency.NULL<-NULL #таким образом мы обнулили объект, NULL часто появляется, когда на выходe получается пустой объект  
class(currency.NULL)
is.null(currency.NULL)

####2b название колонок/рядов
currency.fx[,"uah"] #аналогично currency.fx$uah
currency.fx[,usd] #не забывайте КАВЫЧКИ - а то R думает что это название объекта
a<-"usd"
currency.fx[,a] #а вот так можно
currency.fx[,c("date","uah")]
currency.fx[c("a","c"),c("date","uah")] 
currency.fx[,-c("date","uah")] #минус не работает с названиями
currency.fx[,!names(currency.fx) %in% c("date","uah")] #можно так

currency.uah <- currency.fx[,c("date","uah")] #не забываем что во всех приведеннх случаях, 
#все что выведено на экран можно вместо этого записать как новый объект
currency.uah 

#####третий вариант - специальные функции для subseting
head(currency.fx, n=5) #первые 5 рядов - аналогично currency.fx[1:5,]
tail(currency.fx, n=2) # последние 2 ряда - аналогично currency.fx[(nrow(currency.fx)-1):nrow(currency.fx),]

subset(currency.fx, ("usd"<66.5&eur>75.2)| date=="t") #здесь название колонок можно БЕЗ КАВЫЧЕК (исключение из правила)
#subset полезен если у тебя множественное сравнение, экономит место, так как не надо каждый раз писать название
# data.frame - сравните аналог 
currency.fx[(currency.fx$usd<66.5&currency.fx$eur>75.2)| currency.fx$date=="t",]

mean(subset(currency.fx, usd>66)$usd) #средний курс доллара для случаев когда курс был больше 66
subset(currency.fx, (eur-usd)==max(eur-usd))$date #дата когда разница между курсами была максимальной
# а его аналог без subset 
currency.fx$date[(currency.fx$eur-currency.fx$usd)==max(currency.fx$eur-currency.fx$usd)]

#######ещё полезные функции чтобы не писать все время название data.frame
####with()
currency.fx$new<-with (currency.fx, (eur/uah)*usd+eu) 
with(currency.fx, usd[usd==max(usd)])
#удобно в сочетании с subset
with(subset(currency.fx, usd>66), mean(eur/usd)) #средний евродоллар для ситуации когда курс доллара больше 66



#фигурные скобки позволяют выполнить несколько действий в рамках with
with(subset(currency.fx, usd>66), {
  print(mean(eur/usd))  #print - вывод на экран
  print(sd(eur/usd))
  print(max(eur/usd))
  })



####attach - отменяет необходимость писать название data.frame навсегда, пока не напишешь detach
####количество detach должно быть равно количеству detach
attach(currency.fx)
usd/eur
usd[usd==max(usd)]
detach(currency.fx)

usd/eur

#эта функция опасна, так как
# 1.названия некоторых объектов могут совпадать с названиями колонок data.frame
#когда atach и detach далеко разнесены
date<-5
attach(currency.fx)
usd[date=="m"] #так как есть объект date,то он его успользует а не currency.fx$date
detach(currency.fx)


########Cливание двух датафреймов
###по строкам (количество колонок должно быть равно)
currency.fx<-rbind(currency.fx, data.frame(eur=c(76.5481, 77.5541),usd=c(66.6499, 66.4318), date=c("m","t"),
                                           uah=c(23,24), eu=c(76.5481, 77.5541)/c(66.6499, 66.4318)))
###по колонкам (количество строк долно быть равно)
holidays_time<-data.frame(holidays=c(rep("w",5), "h","h"), time=c(10:16))
currency<-cbind(currency.fx,holidays_time)


########## Задача - узнать делители числа
a<-873
del<-data.frame(del=1:a, result=a/(1:a))
del[(del$result-round(del$result))==0,]$del


#################Задание в классе 2###########################
data_chick<-ChickWeight #ChickWeight - это одна из предустановленных (built-in) data.frame: вес,возраст,номер цыпленка, номер диеты
str(data_chick)

#1. выберите  данные по цыплятам 13-18 и запишите в датафрейм chick_13_18. Далее в заданиях используйте этот дата фрейм
#2. выведите на экран первые и последние 5 строчек датафрейма без колонки Diet
#3. выведите на экран ТОЛЬКО возраст и номер цыпленка с весом меньше 100
#4. выведите на экран все данные цыплят для возраста 12
#5. создайте новую переменную в датафрейм AvSpeed - средняя скорость набора веса (вес/возраст)
#6. как видно скорость для возраста 0 получилась бесконечной, замените для этого возраста значение скорости на NA (вместо inf)
#7. добавьте в датафрейм новую строчку в которой будет средний вес цыпленка 13 за все время, в качестве значения возраста напишите "average"
#обратите внимание что вы таким образом изменили класс вектора Time
 
#################Домашнее задание 2###########################
data_chick<-ChickWeight #работаем снова с ней
summary(data_chick)

#1.среднеквадратичное отклонение веса дсех цыплят для возраста 16, округлить до 3 знака
#2. средний вес всех цыплят в возрасте 2 и с диетой не равной 3, округлить до 3 знака
#3 минимальный вес цыпленка для цыплят возраста 6 из Diet 1 и 4
#4.средний вес всех цыплят для которых в возрасте 14 вес превышал 111 ИЛИ в возрасте 20 был равен 199, округлить до 3 знака
#5.какой номер диеты соотвествовал максимальному среднему весу цыплят в возрасте 20
#6. Какой номер цыпленка максимально отклонялся от среднего в возрасте 8
#7. максимальный номер (Chick) цыпленка у которого вес в каком-либо из возрастов был больше 200, 
#но при этом вес при рождении (Time 0) был меньше 40

